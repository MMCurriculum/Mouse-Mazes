{"ast":null,"code":"var _jsxFileName = \"/Users/joshuaabrams/Library/CloudStorage/Dropbox/Professional Development Activities & Workshops/*Making Math Website/VariedContent/Geometry/LogicAndReasoning/MouseMazes/mouse-mazes-react/src/App.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useCallback, useRef, useEffect } from 'react';\nimport { GameControls } from './components/GameControls/GameControls';\nimport { GameBoard } from './components/GameBoard/GameBoard';\nimport { SidePanel } from './components/SidePanel/SidePanel';\nimport { useMazeGame } from './hooks/useMazeGame';\nimport { useMazeCanvas } from './hooks/useMazeCanvas';\nimport { useAnimation } from './hooks/useAnimation';\nimport { emptyGrid, simulateHoleWithGrid, computeMappingForGrid } from './utils/mazeUtils';\nimport styles from './App.module.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [mode, setMode] = useState('intro');\n  const [mazeType, setMazeType] = useState('walls');\n  const [level, setLevel] = useState('beginner');\n  const [prompt, setPrompt] = useState('Click \"Start New Game\" to begin.\\nIn Introduction mode, you\\'ll get 8 questions on the same maze.\\nIn Inference mode, you\\'ll probe the maze and build your own model.');\n  const [promptIsHTML, setPromptIsHTML] = useState(false);\n  const [feedback, setFeedback] = useState('');\n  const [feedbackClass, setFeedbackClass] = useState('');\n  const [logEntries, setLogEntries] = useState([]);\n  const [questionHistory, setQuestionHistory] = useState([]);\n  const [showHiddenModel, setShowHiddenModel] = useState(false);\n  const [modelDidNotMatch, setModelDidNotMatch] = useState(false);\n  const mouseMarkerRef = useRef(null);\n  const holeRefs = useRef([]);\n  const game = useMazeGame(mazeType, level, mode);\n  const gridToDraw = mode === 'intro' ? game.realGrid : showHiddenModel ? game.realGrid : game.modelGrid;\n  const {\n    canvasRef,\n    ctxRef,\n    drawMaze\n  } = useMazeCanvas(gridToDraw);\n  const {\n    animating,\n    animatePath,\n    animateInferenceProbe\n  } = useAnimation(ctxRef, canvasRef, drawMaze, mouseMarkerRef);\n  const formatQuestionPrompt = useCallback((question, questionIndex, totalQuestions, mazeType, toggleIntroColor) => {\n    const color = toggleIntroColor() ? \"#e67e22\" : \"#1f6ad3\";\n    let scenarioLine = \"\";\n    let rest = \"\";\n    if (question.mode === \"forward\") {\n      scenarioLine = `A mouse leaves hole ${question.startHole}.`;\n      const extra = mazeType === \"arrows\" ? ' (You can also choose \"The Mouse Doesn\\'t Come Out!\")' : \"\";\n      rest = `Where will it come out? Click a hole.${extra}`;\n    } else if (question.mode === \"reverseWalls\") {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"From which hole did it start? Click a starting hole.\";\n    } else {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"Click on one hole that could have been its starting hole.\";\n    }\n    return `Question ${questionIndex} of ${totalQuestions}:<br>` + `<span style=\"font-weight:bold;color:${color};\">${scenarioLine}</span><br>` + `${rest}`;\n  }, []);\n  const formatQuestionForLog = useCallback((question, questionIndex, mazeType) => {\n    let scenarioLine = \"\";\n    let rest = \"\";\n    if (question.mode === \"forward\") {\n      scenarioLine = `A mouse leaves hole ${question.startHole}.`;\n      rest = \"Where will it come out?\";\n    } else if (question.mode === \"reverseWalls\") {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"From which hole did it start?\";\n    } else {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"Click on one hole that could have been its starting hole.\";\n    }\n    return `${scenarioLine} ${rest}`;\n  }, []);\n\n  // Track previous question to add to log when new question appears\n  const prevQuestionRef = useRef(null);\n  const prevQuestionIndexRef = useRef(0);\n\n  // Update prompt when mode changes\n  useEffect(() => {\n    if (mode === 'intro') {\n      setPrompt('Introduction mode:\\nClick \"Start New Game\" to get 8 questions on the same maze.\\nAnswer by clicking a hole (or \"The Mouse Doesn\\'t Come Out!\" when appropriate).');\n      setPromptIsHTML(false);\n    } else {\n      setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n      setPromptIsHTML(false);\n    }\n    setFeedback('');\n    setFeedbackClass('');\n    setQuestionHistory([]);\n    prevQuestionRef.current = null;\n    prevQuestionIndexRef.current = 0;\n    setShowHiddenModel(false);\n    setModelDidNotMatch(false);\n  }, [mode]);\n\n  // Update prompt when question changes\n  useEffect(() => {\n    if (mode === 'intro' && game.currentQuestion && game.questionIndex > 0 && game.questionIndex <= game.TOTAL_QUESTIONS && game.toggleIntroColor) {\n      // If we have a previous question and the index increased, add it to the log\n      if (prevQuestionRef.current && game.questionIndex > prevQuestionIndexRef.current) {\n        const questionText = formatQuestionForLog(prevQuestionRef.current, prevQuestionIndexRef.current, mazeType);\n        setQuestionHistory(prev => [...prev, {\n          questionNumber: prevQuestionIndexRef.current,\n          questionText: questionText\n        }]);\n      }\n      setPrompt(formatQuestionPrompt(game.currentQuestion, game.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n      setPromptIsHTML(true);\n\n      // Update refs for next time\n      prevQuestionRef.current = game.currentQuestion;\n      prevQuestionIndexRef.current = game.questionIndex;\n    }\n  }, [game.currentQuestion, game.questionIndex, mode, mazeType, formatQuestionPrompt, formatQuestionForLog, game.TOTAL_QUESTIONS]);\n  const handleModeChange = useCallback(newMode => {\n    setMode(newMode);\n  }, []);\n  const handleMazeTypeChange = useCallback(newMazeType => {\n    setMazeType(newMazeType);\n  }, []);\n\n  // Automatically start new game when maze type changes\n  const prevMazeTypeRef = useRef(mazeType);\n  const isInitialMountRef = useRef(true);\n  useEffect(() => {\n    // Skip on initial mount\n    if (isInitialMountRef.current) {\n      isInitialMountRef.current = false;\n      prevMazeTypeRef.current = mazeType;\n      return;\n    }\n\n    // Only trigger if maze type actually changed\n    if (prevMazeTypeRef.current !== mazeType) {\n      // Start new game automatically\n      if (mode === 'intro') {\n        const result = game.startIntroGame();\n        if (result && result.question && game.toggleIntroColor) {\n          setPrompt(formatQuestionPrompt(result.question, result.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n          setPromptIsHTML(true);\n          prevQuestionRef.current = result.question;\n          prevQuestionIndexRef.current = result.questionIndex;\n        }\n        setFeedback('');\n        setFeedbackClass('');\n        setQuestionHistory([]);\n      } else {\n        game.startInferenceGame();\n        setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n        setPromptIsHTML(false);\n        setFeedback('');\n        setFeedbackClass('');\n        setLogEntries([]);\n        prevQuestionRef.current = null;\n        prevQuestionIndexRef.current = 0;\n      }\n    }\n    prevMazeTypeRef.current = mazeType;\n  }, [mazeType, mode, game, formatQuestionPrompt]);\n  const handleLevelChange = useCallback(newLevel => {\n    setLevel(newLevel);\n  }, []);\n  const handleNewGame = useCallback(() => {\n    if (mode === 'intro') {\n      const result = game.startIntroGame();\n      if (result && result.question && game.toggleIntroColor) {\n        setPrompt(formatQuestionPrompt(result.question, result.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n        setPromptIsHTML(true);\n        prevQuestionRef.current = result.question;\n        prevQuestionIndexRef.current = result.questionIndex;\n      }\n      setFeedback('');\n      setFeedbackClass('');\n      setQuestionHistory([]);\n    } else {\n      game.startInferenceGame();\n      setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n      setPromptIsHTML(false);\n      setFeedback('');\n      setFeedbackClass('');\n      setLogEntries([]);\n      prevQuestionRef.current = null;\n      prevQuestionIndexRef.current = 0;\n      setShowHiddenModel(false);\n      setModelDidNotMatch(false);\n    }\n  }, [mode, game, mazeType, formatQuestionPrompt]);\n  const handleHoleClick = useCallback(holeNum => {\n    if (animating) return;\n    if (mode === 'intro') {\n      const result = game.handleIntroAnswer(holeNum, false);\n      if (!result) return;\n      animatePath(result.info.path, result.info.exitHole, result.info.trapped, result.animStartHole, () => {\n        const feedbackResult = result.after();\n        if (feedbackResult) {\n          setFeedback(feedbackResult.feedback);\n          setFeedbackClass(feedbackResult.feedbackClass);\n          if (feedbackResult.isCorrect !== undefined) {\n            // Update score display will happen automatically via game state\n            setTimeout(() => {\n              if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                // Get next question\n                game.nextQuestion(game.mapping);\n                // Question will be set in state, we'll update prompt in useEffect\n              } else {\n                setPrompt('Game over. You\\'ve answered all 8 questions.');\n                setPromptIsHTML(false);\n                // Score is already updated in the hook, but we need to account for the current answer\n                const finalScore = feedbackResult.isCorrect ? game.score + 1 : game.score;\n                setFeedback(`You made ${finalScore} out of ${game.TOTAL_QUESTIONS} correct predictions.`);\n                setFeedbackClass('');\n              }\n              setTimeout(() => {\n                if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                  setFeedback('');\n                  setFeedbackClass('');\n                }\n              }, 3000);\n            }, 1800);\n          }\n        }\n      }, gridToDraw);\n    } else {\n      const {\n        info,\n        probeCount\n      } = game.handleInferenceProbe(holeNum);\n      animateInferenceProbe(holeNum, info, () => {\n        if (info.trapped) {\n          setFeedback(`The mouse from hole ${holeNum} is stuck in the house forever.`);\n        } else {\n          setFeedback(`The mouse from hole ${holeNum} came out of hole ${info.exitHole}.`);\n        }\n        setFeedbackClass('');\n        const entry = info.trapped ? `From ${holeNum} → (stuck inside)` : `From ${holeNum} → ${info.exitHole}`;\n        setLogEntries(prev => [...prev, entry]);\n      }, holeRefs.current);\n    }\n  }, [mode, animating, game, animatePath, animateInferenceProbe, gridToDraw, mazeType, formatQuestionPrompt]);\n  const handleNoExitClick = useCallback(() => {\n    if (animating || mode !== 'intro') return;\n    const result = game.handleIntroAnswer(null, true);\n    if (!result) return;\n    animatePath(result.info.path, result.info.exitHole, result.info.trapped, result.animStartHole, () => {\n      const feedbackResult = result.after();\n      if (feedbackResult) {\n        setFeedback(feedbackResult.feedback);\n        setFeedbackClass(feedbackResult.feedbackClass);\n        setTimeout(() => {\n          if (game.questionIndex < game.TOTAL_QUESTIONS) {\n            game.nextQuestion(game.mapping);\n            // Question will be set in state, we'll update prompt in useEffect\n          } else {\n            setPrompt('Game over. You\\'ve answered all 8 questions.');\n            setPromptIsHTML(false);\n            // Score is already updated in the hook, but we need to account for the current answer\n            const finalScore = feedbackResult.isCorrect ? game.score + 1 : game.score;\n            setFeedback(`You made ${finalScore} out of ${game.TOTAL_QUESTIONS} correct predictions.`);\n            setFeedbackClass('');\n          }\n          setTimeout(() => {\n            if (game.questionIndex < game.TOTAL_QUESTIONS) {\n              setFeedback('');\n              setFeedbackClass('');\n            }\n          }, 3000);\n        }, 1800);\n      }\n    }, gridToDraw);\n  }, [animating, mode, game, animatePath, gridToDraw, mazeType, formatQuestionPrompt]);\n  const handleCanvasClick = useCallback((r, c) => {\n    if (mode !== 'inference' || animating) return;\n\n    // If showing hidden model, switch back to user's model when they edit\n    if (showHiddenModel) {\n      setShowHiddenModel(false);\n    }\n    let val = game.modelGrid[r][c];\n    if (mazeType === 'walls') {\n      const seq = ['', '/', '\\\\'];\n      let idx = seq.indexOf(val);\n      if (idx === -1) idx = 0;\n      val = seq[(idx + 1) % seq.length];\n    } else {\n      const seq = ['', 'U', 'R', 'D', 'L'];\n      let idx = seq.indexOf(val);\n      if (idx === -1) idx = 0;\n      val = seq[(idx + 1) % seq.length];\n    }\n    game.updateModelGrid(r, c, val);\n  }, [mode, animating, game, mazeType, showHiddenModel]);\n  const handleTestModel = useCallback(() => {\n    if (mode !== 'inference') return;\n    const result = game.testModel();\n    console.log('handleTestModel result:', result);\n    setFeedback(result.feedback);\n    setFeedbackClass('');\n    // Show \"Show Hidden Model\" button if model didn't match perfectly\n    const shouldShowButton = result.didNotMatch === true;\n    console.log('shouldShowButton:', shouldShowButton, 'result.didNotMatch:', result.didNotMatch);\n    setModelDidNotMatch(shouldShowButton);\n    // Reset show hidden model when testing again\n    setShowHiddenModel(false);\n  }, [mode, game]);\n  const handleShowHiddenModel = useCallback(() => {\n    setShowHiddenModel(true);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: styles.app,\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Mouse Mazes\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 352,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(GameControls, {\n      mode: mode,\n      mazeType: mazeType,\n      level: level,\n      onModeChange: handleModeChange,\n      onMazeTypeChange: handleMazeTypeChange,\n      onLevelChange: handleLevelChange,\n      onNewGame: handleNewGame\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 353,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.gameArea,\n      children: [/*#__PURE__*/_jsxDEV(GameBoard, {\n        mode: mode,\n        gridToDraw: gridToDraw,\n        animating: animating,\n        onHoleClick: handleHoleClick,\n        onCanvasClick: handleCanvasClick,\n        mouseMarkerRef: mouseMarkerRef,\n        holeRefs: holeRefs,\n        canvasRef: canvasRef\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 363,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(SidePanel, {\n        mode: mode,\n        mazeType: mazeType,\n        prompt: prompt,\n        promptIsHTML: promptIsHTML,\n        feedback: feedback,\n        feedbackClass: feedbackClass,\n        score: game.score,\n        questionIndex: game.questionIndex,\n        totalQuestions: game.TOTAL_QUESTIONS,\n        onTestModel: handleTestModel,\n        onNoExitClick: handleNoExitClick,\n        logEntries: logEntries,\n        questionHistory: questionHistory,\n        onShowHiddenModel: handleShowHiddenModel,\n        showHiddenModelButton: modelDidNotMatch && !showHiddenModel\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 373,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 362,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 351,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"EhhUkD6H/RceyQS2UbsP33wiI2E=\", false, function () {\n  return [useMazeGame, useMazeCanvas, useAnimation];\n});\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useCallback","useRef","useEffect","GameControls","GameBoard","SidePanel","useMazeGame","useMazeCanvas","useAnimation","emptyGrid","simulateHoleWithGrid","computeMappingForGrid","styles","jsxDEV","_jsxDEV","App","_s","mode","setMode","mazeType","setMazeType","level","setLevel","prompt","setPrompt","promptIsHTML","setPromptIsHTML","feedback","setFeedback","feedbackClass","setFeedbackClass","logEntries","setLogEntries","questionHistory","setQuestionHistory","showHiddenModel","setShowHiddenModel","modelDidNotMatch","setModelDidNotMatch","mouseMarkerRef","holeRefs","game","gridToDraw","realGrid","modelGrid","canvasRef","ctxRef","drawMaze","animating","animatePath","animateInferenceProbe","formatQuestionPrompt","question","questionIndex","totalQuestions","toggleIntroColor","color","scenarioLine","rest","startHole","extra","endHole","formatQuestionForLog","prevQuestionRef","prevQuestionIndexRef","current","currentQuestion","TOTAL_QUESTIONS","questionText","prev","questionNumber","handleModeChange","newMode","handleMazeTypeChange","newMazeType","prevMazeTypeRef","isInitialMountRef","result","startIntroGame","startInferenceGame","handleLevelChange","newLevel","handleNewGame","handleHoleClick","holeNum","handleIntroAnswer","info","path","exitHole","trapped","animStartHole","feedbackResult","after","isCorrect","undefined","setTimeout","nextQuestion","mapping","finalScore","score","probeCount","handleInferenceProbe","entry","handleNoExitClick","handleCanvasClick","r","c","val","seq","idx","indexOf","length","updateModelGrid","handleTestModel","testModel","console","log","shouldShowButton","didNotMatch","handleShowHiddenModel","className","app","children","fileName","_jsxFileName","lineNumber","columnNumber","onModeChange","onMazeTypeChange","onLevelChange","onNewGame","gameArea","onHoleClick","onCanvasClick","onTestModel","onNoExitClick","onShowHiddenModel","showHiddenModelButton","_c","$RefreshReg$"],"sources":["/Users/joshuaabrams/Library/CloudStorage/Dropbox/Professional Development Activities & Workshops/*Making Math Website/VariedContent/Geometry/LogicAndReasoning/MouseMazes/mouse-mazes-react/src/App.jsx"],"sourcesContent":["import React, { useState, useCallback, useRef, useEffect } from 'react';\nimport { GameControls } from './components/GameControls/GameControls';\nimport { GameBoard } from './components/GameBoard/GameBoard';\nimport { SidePanel } from './components/SidePanel/SidePanel';\nimport { useMazeGame } from './hooks/useMazeGame';\nimport { useMazeCanvas } from './hooks/useMazeCanvas';\nimport { useAnimation } from './hooks/useAnimation';\nimport { emptyGrid, simulateHoleWithGrid, computeMappingForGrid } from './utils/mazeUtils';\nimport styles from './App.module.css';\n\nfunction App() {\n  const [mode, setMode] = useState('intro');\n  const [mazeType, setMazeType] = useState('walls');\n  const [level, setLevel] = useState('beginner');\n  const [prompt, setPrompt] = useState('Click \"Start New Game\" to begin.\\nIn Introduction mode, you\\'ll get 8 questions on the same maze.\\nIn Inference mode, you\\'ll probe the maze and build your own model.');\n  const [promptIsHTML, setPromptIsHTML] = useState(false);\n  const [feedback, setFeedback] = useState('');\n  const [feedbackClass, setFeedbackClass] = useState('');\n  const [logEntries, setLogEntries] = useState([]);\n  const [questionHistory, setQuestionHistory] = useState([]);\n  const [showHiddenModel, setShowHiddenModel] = useState(false);\n  const [modelDidNotMatch, setModelDidNotMatch] = useState(false);\n  \n  const mouseMarkerRef = useRef(null);\n  const holeRefs = useRef([]);\n  \n  const game = useMazeGame(mazeType, level, mode);\n  const gridToDraw = mode === 'intro' ? game.realGrid : (showHiddenModel ? game.realGrid : game.modelGrid);\n  const { canvasRef, ctxRef, drawMaze } = useMazeCanvas(gridToDraw);\n  const { animating, animatePath, animateInferenceProbe } = useAnimation(\n    ctxRef,\n    canvasRef,\n    drawMaze,\n    mouseMarkerRef\n  );\n\n  const formatQuestionPrompt = useCallback((question, questionIndex, totalQuestions, mazeType, toggleIntroColor) => {\n    const color = toggleIntroColor() ? \"#e67e22\" : \"#1f6ad3\";\n    let scenarioLine = \"\";\n    let rest = \"\";\n\n    if (question.mode === \"forward\") {\n      scenarioLine = `A mouse leaves hole ${question.startHole}.`;\n      const extra = (mazeType === \"arrows\")\n        ? ' (You can also choose \"The Mouse Doesn\\'t Come Out!\")'\n        : \"\";\n      rest = `Where will it come out? Click a hole.${extra}`;\n    } else if (question.mode === \"reverseWalls\") {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"From which hole did it start? Click a starting hole.\";\n    } else {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"Click on one hole that could have been its starting hole.\";\n    }\n\n    return `Question ${questionIndex} of ${totalQuestions}:<br>` +\n      `<span style=\"font-weight:bold;color:${color};\">${scenarioLine}</span><br>` +\n      `${rest}`;\n  }, []);\n\n  const formatQuestionForLog = useCallback((question, questionIndex, mazeType) => {\n    let scenarioLine = \"\";\n    let rest = \"\";\n\n    if (question.mode === \"forward\") {\n      scenarioLine = `A mouse leaves hole ${question.startHole}.`;\n      rest = \"Where will it come out?\";\n    } else if (question.mode === \"reverseWalls\") {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"From which hole did it start?\";\n    } else {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"Click on one hole that could have been its starting hole.\";\n    }\n\n    return `${scenarioLine} ${rest}`;\n  }, []);\n\n  // Track previous question to add to log when new question appears\n  const prevQuestionRef = useRef(null);\n  const prevQuestionIndexRef = useRef(0);\n\n  // Update prompt when mode changes\n  useEffect(() => {\n    if (mode === 'intro') {\n      setPrompt('Introduction mode:\\nClick \"Start New Game\" to get 8 questions on the same maze.\\nAnswer by clicking a hole (or \"The Mouse Doesn\\'t Come Out!\" when appropriate).');\n      setPromptIsHTML(false);\n    } else {\n      setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n      setPromptIsHTML(false);\n    }\n    setFeedback('');\n    setFeedbackClass('');\n    setQuestionHistory([]);\n    prevQuestionRef.current = null;\n    prevQuestionIndexRef.current = 0;\n    setShowHiddenModel(false);\n    setModelDidNotMatch(false);\n  }, [mode]);\n\n  // Update prompt when question changes\n  useEffect(() => {\n    if (mode === 'intro' && game.currentQuestion && game.questionIndex > 0 && game.questionIndex <= game.TOTAL_QUESTIONS && game.toggleIntroColor) {\n      // If we have a previous question and the index increased, add it to the log\n      if (prevQuestionRef.current && game.questionIndex > prevQuestionIndexRef.current) {\n        const questionText = formatQuestionForLog(prevQuestionRef.current, prevQuestionIndexRef.current, mazeType);\n        setQuestionHistory(prev => [...prev, {\n          questionNumber: prevQuestionIndexRef.current,\n          questionText: questionText\n        }]);\n      }\n      \n      setPrompt(formatQuestionPrompt(game.currentQuestion, game.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n      setPromptIsHTML(true);\n      \n      // Update refs for next time\n      prevQuestionRef.current = game.currentQuestion;\n      prevQuestionIndexRef.current = game.questionIndex;\n    }\n  }, [game.currentQuestion, game.questionIndex, mode, mazeType, formatQuestionPrompt, formatQuestionForLog, game.TOTAL_QUESTIONS]);\n\n  const handleModeChange = useCallback((newMode) => {\n    setMode(newMode);\n  }, []);\n\n  const handleMazeTypeChange = useCallback((newMazeType) => {\n    setMazeType(newMazeType);\n  }, []);\n\n  // Automatically start new game when maze type changes\n  const prevMazeTypeRef = useRef(mazeType);\n  const isInitialMountRef = useRef(true);\n  useEffect(() => {\n    // Skip on initial mount\n    if (isInitialMountRef.current) {\n      isInitialMountRef.current = false;\n      prevMazeTypeRef.current = mazeType;\n      return;\n    }\n    \n    // Only trigger if maze type actually changed\n    if (prevMazeTypeRef.current !== mazeType) {\n      // Start new game automatically\n      if (mode === 'intro') {\n        const result = game.startIntroGame();\n        if (result && result.question && game.toggleIntroColor) {\n          setPrompt(formatQuestionPrompt(result.question, result.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n          setPromptIsHTML(true);\n          prevQuestionRef.current = result.question;\n          prevQuestionIndexRef.current = result.questionIndex;\n        }\n        setFeedback('');\n        setFeedbackClass('');\n        setQuestionHistory([]);\n      } else {\n        game.startInferenceGame();\n        setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n        setPromptIsHTML(false);\n        setFeedback('');\n        setFeedbackClass('');\n        setLogEntries([]);\n        prevQuestionRef.current = null;\n        prevQuestionIndexRef.current = 0;\n      }\n    }\n    prevMazeTypeRef.current = mazeType;\n  }, [mazeType, mode, game, formatQuestionPrompt]);\n\n  const handleLevelChange = useCallback((newLevel) => {\n    setLevel(newLevel);\n  }, []);\n\n  const handleNewGame = useCallback(() => {\n    if (mode === 'intro') {\n      const result = game.startIntroGame();\n      if (result && result.question && game.toggleIntroColor) {\n        setPrompt(formatQuestionPrompt(result.question, result.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n        setPromptIsHTML(true);\n        prevQuestionRef.current = result.question;\n        prevQuestionIndexRef.current = result.questionIndex;\n      }\n      setFeedback('');\n      setFeedbackClass('');\n      setQuestionHistory([]);\n    } else {\n      game.startInferenceGame();\n      setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n      setPromptIsHTML(false);\n      setFeedback('');\n      setFeedbackClass('');\n      setLogEntries([]);\n      prevQuestionRef.current = null;\n      prevQuestionIndexRef.current = 0;\n      setShowHiddenModel(false);\n      setModelDidNotMatch(false);\n    }\n  }, [mode, game, mazeType, formatQuestionPrompt]);\n\n  const handleHoleClick = useCallback((holeNum) => {\n    if (animating) return;\n\n    if (mode === 'intro') {\n      const result = game.handleIntroAnswer(holeNum, false);\n      if (!result) return;\n      \n      animatePath(\n        result.info.path,\n        result.info.exitHole,\n        result.info.trapped,\n        result.animStartHole,\n        () => {\n          const feedbackResult = result.after();\n          if (feedbackResult) {\n            setFeedback(feedbackResult.feedback);\n            setFeedbackClass(feedbackResult.feedbackClass);\n            \n            if (feedbackResult.isCorrect !== undefined) {\n              // Update score display will happen automatically via game state\n              setTimeout(() => {\n                if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                  // Get next question\n                  game.nextQuestion(game.mapping);\n                  // Question will be set in state, we'll update prompt in useEffect\n                } else {\n                  setPrompt('Game over. You\\'ve answered all 8 questions.');\n                  setPromptIsHTML(false);\n                  // Score is already updated in the hook, but we need to account for the current answer\n                  const finalScore = feedbackResult.isCorrect ? game.score + 1 : game.score;\n                  setFeedback(`You made ${finalScore} out of ${game.TOTAL_QUESTIONS} correct predictions.`);\n                  setFeedbackClass('');\n                }\n                \n                setTimeout(() => {\n                  if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                    setFeedback('');\n                    setFeedbackClass('');\n                  }\n                }, 3000);\n              }, 1800);\n            }\n          }\n        },\n        gridToDraw\n      );\n    } else {\n      const { info, probeCount } = game.handleInferenceProbe(holeNum);\n      animateInferenceProbe(\n        holeNum,\n        info,\n        () => {\n          if (info.trapped) {\n            setFeedback(`The mouse from hole ${holeNum} is stuck in the house forever.`);\n          } else {\n            setFeedback(`The mouse from hole ${holeNum} came out of hole ${info.exitHole}.`);\n          }\n          setFeedbackClass('');\n          const entry = info.trapped\n            ? `From ${holeNum} → (stuck inside)`\n            : `From ${holeNum} → ${info.exitHole}`;\n          setLogEntries(prev => [...prev, entry]);\n        },\n        holeRefs.current\n      );\n    }\n  }, [mode, animating, game, animatePath, animateInferenceProbe, gridToDraw, mazeType, formatQuestionPrompt]);\n\n  const handleNoExitClick = useCallback(() => {\n    if (animating || mode !== 'intro') return;\n    const result = game.handleIntroAnswer(null, true);\n    if (!result) return;\n    \n    animatePath(\n      result.info.path,\n      result.info.exitHole,\n      result.info.trapped,\n      result.animStartHole,\n      () => {\n        const feedbackResult = result.after();\n        if (feedbackResult) {\n          setFeedback(feedbackResult.feedback);\n          setFeedbackClass(feedbackResult.feedbackClass);\n          \n          setTimeout(() => {\n            if (game.questionIndex < game.TOTAL_QUESTIONS) {\n              game.nextQuestion(game.mapping);\n              // Question will be set in state, we'll update prompt in useEffect\n            } else {\n              setPrompt('Game over. You\\'ve answered all 8 questions.');\n              setPromptIsHTML(false);\n              // Score is already updated in the hook, but we need to account for the current answer\n              const finalScore = feedbackResult.isCorrect ? game.score + 1 : game.score;\n              setFeedback(`You made ${finalScore} out of ${game.TOTAL_QUESTIONS} correct predictions.`);\n              setFeedbackClass('');\n            }\n            \n            setTimeout(() => {\n              if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                setFeedback('');\n                setFeedbackClass('');\n              }\n            }, 3000);\n          }, 1800);\n        }\n      },\n      gridToDraw\n    );\n  }, [animating, mode, game, animatePath, gridToDraw, mazeType, formatQuestionPrompt]);\n\n  const handleCanvasClick = useCallback((r, c) => {\n    if (mode !== 'inference' || animating) return;\n    \n    // If showing hidden model, switch back to user's model when they edit\n    if (showHiddenModel) {\n      setShowHiddenModel(false);\n    }\n    \n    let val = game.modelGrid[r][c];\n    if (mazeType === 'walls') {\n      const seq = ['', '/', '\\\\'];\n      let idx = seq.indexOf(val);\n      if (idx === -1) idx = 0;\n      val = seq[(idx + 1) % seq.length];\n    } else {\n      const seq = ['', 'U', 'R', 'D', 'L'];\n      let idx = seq.indexOf(val);\n      if (idx === -1) idx = 0;\n      val = seq[(idx + 1) % seq.length];\n    }\n    game.updateModelGrid(r, c, val);\n  }, [mode, animating, game, mazeType, showHiddenModel]);\n\n  const handleTestModel = useCallback(() => {\n    if (mode !== 'inference') return;\n    const result = game.testModel();\n    console.log('handleTestModel result:', result);\n    setFeedback(result.feedback);\n    setFeedbackClass('');\n    // Show \"Show Hidden Model\" button if model didn't match perfectly\n    const shouldShowButton = result.didNotMatch === true;\n    console.log('shouldShowButton:', shouldShowButton, 'result.didNotMatch:', result.didNotMatch);\n    setModelDidNotMatch(shouldShowButton);\n    // Reset show hidden model when testing again\n    setShowHiddenModel(false);\n  }, [mode, game]);\n\n  const handleShowHiddenModel = useCallback(() => {\n    setShowHiddenModel(true);\n  }, []);\n\n  return (\n    <div className={styles.app}>\n      <h1>Mouse Mazes</h1>\n      <GameControls\n        mode={mode}\n        mazeType={mazeType}\n        level={level}\n        onModeChange={handleModeChange}\n        onMazeTypeChange={handleMazeTypeChange}\n        onLevelChange={handleLevelChange}\n        onNewGame={handleNewGame}\n      />\n      <div className={styles.gameArea}>\n        <GameBoard\n          mode={mode}\n          gridToDraw={gridToDraw}\n          animating={animating}\n          onHoleClick={handleHoleClick}\n          onCanvasClick={handleCanvasClick}\n          mouseMarkerRef={mouseMarkerRef}\n          holeRefs={holeRefs}\n          canvasRef={canvasRef}\n        />\n        <SidePanel\n          mode={mode}\n          mazeType={mazeType}\n          prompt={prompt}\n          promptIsHTML={promptIsHTML}\n          feedback={feedback}\n          feedbackClass={feedbackClass}\n          score={game.score}\n          questionIndex={game.questionIndex}\n          totalQuestions={game.TOTAL_QUESTIONS}\n          onTestModel={handleTestModel}\n          onNoExitClick={handleNoExitClick}\n          logEntries={logEntries}\n          questionHistory={questionHistory}\n          onShowHiddenModel={handleShowHiddenModel}\n          showHiddenModelButton={modelDidNotMatch && !showHiddenModel}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}