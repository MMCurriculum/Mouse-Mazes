{"ast":null,"code":"var _jsxFileName = \"/Users/joshuaabrams/Library/CloudStorage/Dropbox/Professional Development Activities & Workshops/*Making Math Website/VariedContent/Geometry/LogicAndReasoning/MouseMazes/mouse-mazes-react/src/App.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useCallback, useRef, useEffect } from 'react';\nimport { GameControls } from './components/GameControls/GameControls';\nimport { GameBoard } from './components/GameBoard/GameBoard';\nimport { SidePanel } from './components/SidePanel/SidePanel';\nimport { useMazeGame } from './hooks/useMazeGame';\nimport { useMazeCanvas } from './hooks/useMazeCanvas';\nimport { useAnimation } from './hooks/useAnimation';\nimport { emptyGrid, simulateHoleWithGrid, computeMappingForGrid } from './utils/mazeUtils';\nimport styles from './App.module.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [mode, setMode] = useState('intro');\n  const [mazeType, setMazeType] = useState('walls');\n  const [level, setLevel] = useState('beginner');\n  const [prompt, setPrompt] = useState('Click \"Start New Game\" to begin.\\nIn Introduction mode, you\\'ll get 8 questions on the same maze.\\nIn Inference mode, you\\'ll probe the maze and build your own model.');\n  const [promptIsHTML, setPromptIsHTML] = useState(false);\n  const [feedback, setFeedback] = useState('');\n  const [feedbackClass, setFeedbackClass] = useState('');\n  const [logEntries, setLogEntries] = useState([]);\n  const [questionHistory, setQuestionHistory] = useState([]);\n  const mouseMarkerRef = useRef(null);\n  const holeRefs = useRef([]);\n  const game = useMazeGame(mazeType, level, mode);\n  const gridToDraw = mode === 'intro' ? game.realGrid : game.modelGrid;\n  const {\n    canvasRef,\n    ctxRef,\n    drawMaze\n  } = useMazeCanvas(gridToDraw);\n  const {\n    animating,\n    animatePath,\n    animateInferenceProbe\n  } = useAnimation(ctxRef, canvasRef, drawMaze, mouseMarkerRef);\n  const formatQuestionPrompt = useCallback((question, questionIndex, totalQuestions, mazeType, toggleIntroColor) => {\n    const color = toggleIntroColor() ? \"#e67e22\" : \"#1f6ad3\";\n    let scenarioLine = \"\";\n    let rest = \"\";\n    if (question.mode === \"forward\") {\n      scenarioLine = `A mouse leaves hole ${question.startHole}.`;\n      const extra = mazeType === \"arrows\" ? ' (You can also choose \"The Mouse Doesn\\'t Come Out!\")' : \"\";\n      rest = `Where will it come out? Click a hole.${extra}`;\n    } else if (question.mode === \"reverseWalls\") {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"From which hole did it start? Click a starting hole.\";\n    } else {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"Click on one hole that could have been its starting hole.\";\n    }\n    return `Question ${questionIndex} of ${totalQuestions}:<br>` + `<span style=\"font-weight:bold;color:${color};\">${scenarioLine}</span><br>` + `${rest}`;\n  }, []);\n  const formatQuestionForLog = useCallback((question, questionIndex, mazeType) => {\n    let scenarioLine = \"\";\n    let rest = \"\";\n    if (question.mode === \"forward\") {\n      scenarioLine = `A mouse leaves hole ${question.startHole}.`;\n      rest = \"Where will it come out?\";\n    } else if (question.mode === \"reverseWalls\") {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"From which hole did it start?\";\n    } else {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"Click on one hole that could have been its starting hole.\";\n    }\n    return `${scenarioLine} ${rest}`;\n  }, []);\n\n  // Update prompt when mode changes\n  useEffect(() => {\n    if (mode === 'intro') {\n      setPrompt('Introduction mode:\\nClick \"Start New Game\" to get 8 questions on the same maze.\\nAnswer by clicking a hole (or \"The Mouse Doesn\\'t Come Out!\" when appropriate).');\n      setPromptIsHTML(false);\n    } else {\n      setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n      setPromptIsHTML(false);\n    }\n    setFeedback('');\n    setFeedbackClass('');\n    setQuestionHistory([]);\n  }, [mode]);\n\n  // Track previous question to add to log when new question appears\n  const prevQuestionRef = useRef(null);\n  const prevQuestionIndexRef = useRef(0);\n\n  // Update prompt when question changes\n  useEffect(() => {\n    if (mode === 'intro' && game.currentQuestion && game.questionIndex > 0 && game.questionIndex <= game.TOTAL_QUESTIONS && game.toggleIntroColor) {\n      // If we have a previous question and the index increased, add it to the log\n      if (prevQuestionRef.current && game.questionIndex > prevQuestionIndexRef.current) {\n        const questionText = formatQuestionForLog(prevQuestionRef.current, prevQuestionIndexRef.current, mazeType);\n        setQuestionHistory(prev => [...prev, {\n          questionNumber: prevQuestionIndexRef.current,\n          questionText: questionText\n        }]);\n      }\n      setPrompt(formatQuestionPrompt(game.currentQuestion, game.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n      setPromptIsHTML(true);\n\n      // Update refs for next time\n      prevQuestionRef.current = game.currentQuestion;\n      prevQuestionIndexRef.current = game.questionIndex;\n    }\n  }, [game.currentQuestion, game.questionIndex, mode, mazeType, formatQuestionPrompt, formatQuestionForLog, game.TOTAL_QUESTIONS]);\n  const handleModeChange = useCallback(newMode => {\n    setMode(newMode);\n  }, []);\n  const handleMazeTypeChange = useCallback(newMazeType => {\n    setMazeType(newMazeType);\n  }, []);\n  const handleLevelChange = useCallback(newLevel => {\n    setLevel(newLevel);\n  }, []);\n  const handleNewGame = useCallback(() => {\n    if (mode === 'intro') {\n      const result = game.startIntroGame();\n      if (result && result.question && game.toggleIntroColor) {\n        setPrompt(formatQuestionPrompt(result.question, result.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n        setPromptIsHTML(true);\n        prevQuestionRef.current = result.question;\n        prevQuestionIndexRef.current = result.questionIndex;\n      }\n      setFeedback('');\n      setFeedbackClass('');\n      setQuestionHistory([]);\n    } else {\n      game.startInferenceGame();\n      setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n      setPromptIsHTML(false);\n      setFeedback('');\n      setFeedbackClass('');\n      setLogEntries([]);\n    }\n  }, [mode, game, mazeType, formatQuestionPrompt]);\n  const handleHoleClick = useCallback(holeNum => {\n    if (animating) return;\n    if (mode === 'intro') {\n      const result = game.handleIntroAnswer(holeNum, false);\n      if (!result) return;\n      animatePath(result.info.path, result.info.exitHole, result.info.trapped, result.animStartHole, () => {\n        const feedbackResult = result.after();\n        if (feedbackResult) {\n          setFeedback(feedbackResult.feedback);\n          setFeedbackClass(feedbackResult.feedbackClass);\n          if (feedbackResult.isCorrect !== undefined) {\n            // Update score display will happen automatically via game state\n            setTimeout(() => {\n              if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                // Get next question\n                game.nextQuestion(game.mapping);\n                // Question will be set in state, we'll update prompt in useEffect\n              } else {\n                setPrompt('Game over. You\\'ve answered all 8 questions.');\n                setPromptIsHTML(false);\n                // Score is already updated in the hook, but we need to account for the current answer\n                const finalScore = feedbackResult.isCorrect ? game.score + 1 : game.score;\n                setFeedback(`You made ${finalScore} out of ${game.TOTAL_QUESTIONS} correct predictions.`);\n                setFeedbackClass('');\n              }\n              setTimeout(() => {\n                if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                  setFeedback('');\n                  setFeedbackClass('');\n                }\n              }, 3000);\n            }, 1800);\n          }\n        }\n      }, gridToDraw);\n    } else {\n      const {\n        info,\n        probeCount\n      } = game.handleInferenceProbe(holeNum);\n      animateInferenceProbe(holeNum, info, () => {\n        if (info.trapped) {\n          setFeedback(`The mouse from hole ${holeNum} is stuck in the house forever.`);\n        } else {\n          setFeedback(`The mouse from hole ${holeNum} came out of hole ${info.exitHole}.`);\n        }\n        setFeedbackClass('');\n        const entry = info.trapped ? `From ${holeNum} → (stuck inside)` : `From ${holeNum} → ${info.exitHole}`;\n        setLogEntries(prev => [...prev, entry]);\n      }, holeRefs.current);\n    }\n  }, [mode, animating, game, animatePath, animateInferenceProbe, gridToDraw, mazeType, formatQuestionPrompt]);\n  const handleNoExitClick = useCallback(() => {\n    if (animating || mode !== 'intro') return;\n    const result = game.handleIntroAnswer(null, true);\n    if (!result) return;\n    animatePath(result.info.path, result.info.exitHole, result.info.trapped, result.animStartHole, () => {\n      const feedbackResult = result.after();\n      if (feedbackResult) {\n        setFeedback(feedbackResult.feedback);\n        setFeedbackClass(feedbackResult.feedbackClass);\n        setTimeout(() => {\n          if (game.questionIndex < game.TOTAL_QUESTIONS) {\n            game.nextQuestion(game.mapping);\n            // Question will be set in state, we'll update prompt in useEffect\n          } else {\n            setPrompt('Game over. You\\'ve answered all 8 questions.');\n            setPromptIsHTML(false);\n            // Score is already updated in the hook, but we need to account for the current answer\n            const finalScore = feedbackResult.isCorrect ? game.score + 1 : game.score;\n            setFeedback(`You made ${finalScore} out of ${game.TOTAL_QUESTIONS} correct predictions.`);\n            setFeedbackClass('');\n          }\n          setTimeout(() => {\n            if (game.questionIndex < game.TOTAL_QUESTIONS) {\n              setFeedback('');\n              setFeedbackClass('');\n            }\n          }, 3000);\n        }, 1800);\n      }\n    }, gridToDraw);\n  }, [animating, mode, game, animatePath, gridToDraw, mazeType, formatQuestionPrompt]);\n  const handleCanvasClick = useCallback((r, c) => {\n    if (mode !== 'inference' || animating) return;\n    let val = game.modelGrid[r][c];\n    if (mazeType === 'walls') {\n      const seq = ['', '/', '\\\\'];\n      let idx = seq.indexOf(val);\n      if (idx === -1) idx = 0;\n      val = seq[(idx + 1) % seq.length];\n    } else {\n      const seq = ['', 'U', 'R', 'D', 'L'];\n      let idx = seq.indexOf(val);\n      if (idx === -1) idx = 0;\n      val = seq[(idx + 1) % seq.length];\n    }\n    game.updateModelGrid(r, c, val);\n  }, [mode, animating, game, mazeType]);\n  const handleTestModel = useCallback(() => {\n    if (mode !== 'inference') return;\n    const result = game.testModel();\n    setFeedback(result.feedback);\n    setFeedbackClass('');\n  }, [mode, game]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: styles.app,\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Mouse Mazes\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 287,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(GameControls, {\n      mode: mode,\n      mazeType: mazeType,\n      level: level,\n      onModeChange: handleModeChange,\n      onMazeTypeChange: handleMazeTypeChange,\n      onLevelChange: handleLevelChange,\n      onNewGame: handleNewGame\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 288,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.gameArea,\n      children: [/*#__PURE__*/_jsxDEV(GameBoard, {\n        mode: mode,\n        gridToDraw: gridToDraw,\n        animating: animating,\n        onHoleClick: handleHoleClick,\n        onCanvasClick: handleCanvasClick,\n        mouseMarkerRef: mouseMarkerRef,\n        holeRefs: holeRefs,\n        canvasRef: canvasRef\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 298,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(SidePanel, {\n        mode: mode,\n        mazeType: mazeType,\n        prompt: prompt,\n        promptIsHTML: promptIsHTML,\n        feedback: feedback,\n        feedbackClass: feedbackClass,\n        score: game.score,\n        questionIndex: game.questionIndex,\n        totalQuestions: game.TOTAL_QUESTIONS,\n        onTestModel: handleTestModel,\n        onNoExitClick: handleNoExitClick,\n        logEntries: logEntries,\n        questionHistory: questionHistory\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 308,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 297,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 286,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"HT1dR3rcOIiwuCXBMllQYXU6G2M=\", false, function () {\n  return [useMazeGame, useMazeCanvas, useAnimation];\n});\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useCallback","useRef","useEffect","GameControls","GameBoard","SidePanel","useMazeGame","useMazeCanvas","useAnimation","emptyGrid","simulateHoleWithGrid","computeMappingForGrid","styles","jsxDEV","_jsxDEV","App","_s","mode","setMode","mazeType","setMazeType","level","setLevel","prompt","setPrompt","promptIsHTML","setPromptIsHTML","feedback","setFeedback","feedbackClass","setFeedbackClass","logEntries","setLogEntries","questionHistory","setQuestionHistory","mouseMarkerRef","holeRefs","game","gridToDraw","realGrid","modelGrid","canvasRef","ctxRef","drawMaze","animating","animatePath","animateInferenceProbe","formatQuestionPrompt","question","questionIndex","totalQuestions","toggleIntroColor","color","scenarioLine","rest","startHole","extra","endHole","formatQuestionForLog","prevQuestionRef","prevQuestionIndexRef","currentQuestion","TOTAL_QUESTIONS","current","questionText","prev","questionNumber","handleModeChange","newMode","handleMazeTypeChange","newMazeType","handleLevelChange","newLevel","handleNewGame","result","startIntroGame","startInferenceGame","handleHoleClick","holeNum","handleIntroAnswer","info","path","exitHole","trapped","animStartHole","feedbackResult","after","isCorrect","undefined","setTimeout","nextQuestion","mapping","finalScore","score","probeCount","handleInferenceProbe","entry","handleNoExitClick","handleCanvasClick","r","c","val","seq","idx","indexOf","length","updateModelGrid","handleTestModel","testModel","className","app","children","fileName","_jsxFileName","lineNumber","columnNumber","onModeChange","onMazeTypeChange","onLevelChange","onNewGame","gameArea","onHoleClick","onCanvasClick","onTestModel","onNoExitClick","_c","$RefreshReg$"],"sources":["/Users/joshuaabrams/Library/CloudStorage/Dropbox/Professional Development Activities & Workshops/*Making Math Website/VariedContent/Geometry/LogicAndReasoning/MouseMazes/mouse-mazes-react/src/App.jsx"],"sourcesContent":["import React, { useState, useCallback, useRef, useEffect } from 'react';\nimport { GameControls } from './components/GameControls/GameControls';\nimport { GameBoard } from './components/GameBoard/GameBoard';\nimport { SidePanel } from './components/SidePanel/SidePanel';\nimport { useMazeGame } from './hooks/useMazeGame';\nimport { useMazeCanvas } from './hooks/useMazeCanvas';\nimport { useAnimation } from './hooks/useAnimation';\nimport { emptyGrid, simulateHoleWithGrid, computeMappingForGrid } from './utils/mazeUtils';\nimport styles from './App.module.css';\n\nfunction App() {\n  const [mode, setMode] = useState('intro');\n  const [mazeType, setMazeType] = useState('walls');\n  const [level, setLevel] = useState('beginner');\n  const [prompt, setPrompt] = useState('Click \"Start New Game\" to begin.\\nIn Introduction mode, you\\'ll get 8 questions on the same maze.\\nIn Inference mode, you\\'ll probe the maze and build your own model.');\n  const [promptIsHTML, setPromptIsHTML] = useState(false);\n  const [feedback, setFeedback] = useState('');\n  const [feedbackClass, setFeedbackClass] = useState('');\n  const [logEntries, setLogEntries] = useState([]);\n  const [questionHistory, setQuestionHistory] = useState([]);\n  \n  const mouseMarkerRef = useRef(null);\n  const holeRefs = useRef([]);\n  \n  const game = useMazeGame(mazeType, level, mode);\n  const gridToDraw = mode === 'intro' ? game.realGrid : game.modelGrid;\n  const { canvasRef, ctxRef, drawMaze } = useMazeCanvas(gridToDraw);\n  const { animating, animatePath, animateInferenceProbe } = useAnimation(\n    ctxRef,\n    canvasRef,\n    drawMaze,\n    mouseMarkerRef\n  );\n\n  const formatQuestionPrompt = useCallback((question, questionIndex, totalQuestions, mazeType, toggleIntroColor) => {\n    const color = toggleIntroColor() ? \"#e67e22\" : \"#1f6ad3\";\n    let scenarioLine = \"\";\n    let rest = \"\";\n\n    if (question.mode === \"forward\") {\n      scenarioLine = `A mouse leaves hole ${question.startHole}.`;\n      const extra = (mazeType === \"arrows\")\n        ? ' (You can also choose \"The Mouse Doesn\\'t Come Out!\")'\n        : \"\";\n      rest = `Where will it come out? Click a hole.${extra}`;\n    } else if (question.mode === \"reverseWalls\") {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"From which hole did it start? Click a starting hole.\";\n    } else {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"Click on one hole that could have been its starting hole.\";\n    }\n\n    return `Question ${questionIndex} of ${totalQuestions}:<br>` +\n      `<span style=\"font-weight:bold;color:${color};\">${scenarioLine}</span><br>` +\n      `${rest}`;\n  }, []);\n\n  const formatQuestionForLog = useCallback((question, questionIndex, mazeType) => {\n    let scenarioLine = \"\";\n    let rest = \"\";\n\n    if (question.mode === \"forward\") {\n      scenarioLine = `A mouse leaves hole ${question.startHole}.`;\n      rest = \"Where will it come out?\";\n    } else if (question.mode === \"reverseWalls\") {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"From which hole did it start?\";\n    } else {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"Click on one hole that could have been its starting hole.\";\n    }\n\n    return `${scenarioLine} ${rest}`;\n  }, []);\n\n  // Update prompt when mode changes\n  useEffect(() => {\n    if (mode === 'intro') {\n      setPrompt('Introduction mode:\\nClick \"Start New Game\" to get 8 questions on the same maze.\\nAnswer by clicking a hole (or \"The Mouse Doesn\\'t Come Out!\" when appropriate).');\n      setPromptIsHTML(false);\n    } else {\n      setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n      setPromptIsHTML(false);\n    }\n    setFeedback('');\n    setFeedbackClass('');\n    setQuestionHistory([]);\n  }, [mode]);\n\n  // Track previous question to add to log when new question appears\n  const prevQuestionRef = useRef(null);\n  const prevQuestionIndexRef = useRef(0);\n\n  // Update prompt when question changes\n  useEffect(() => {\n    if (mode === 'intro' && game.currentQuestion && game.questionIndex > 0 && game.questionIndex <= game.TOTAL_QUESTIONS && game.toggleIntroColor) {\n      // If we have a previous question and the index increased, add it to the log\n      if (prevQuestionRef.current && game.questionIndex > prevQuestionIndexRef.current) {\n        const questionText = formatQuestionForLog(prevQuestionRef.current, prevQuestionIndexRef.current, mazeType);\n        setQuestionHistory(prev => [...prev, {\n          questionNumber: prevQuestionIndexRef.current,\n          questionText: questionText\n        }]);\n      }\n      \n      setPrompt(formatQuestionPrompt(game.currentQuestion, game.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n      setPromptIsHTML(true);\n      \n      // Update refs for next time\n      prevQuestionRef.current = game.currentQuestion;\n      prevQuestionIndexRef.current = game.questionIndex;\n    }\n  }, [game.currentQuestion, game.questionIndex, mode, mazeType, formatQuestionPrompt, formatQuestionForLog, game.TOTAL_QUESTIONS]);\n\n  const handleModeChange = useCallback((newMode) => {\n    setMode(newMode);\n  }, []);\n\n  const handleMazeTypeChange = useCallback((newMazeType) => {\n    setMazeType(newMazeType);\n  }, []);\n\n  const handleLevelChange = useCallback((newLevel) => {\n    setLevel(newLevel);\n  }, []);\n\n  const handleNewGame = useCallback(() => {\n    if (mode === 'intro') {\n      const result = game.startIntroGame();\n      if (result && result.question && game.toggleIntroColor) {\n        setPrompt(formatQuestionPrompt(result.question, result.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n        setPromptIsHTML(true);\n        prevQuestionRef.current = result.question;\n        prevQuestionIndexRef.current = result.questionIndex;\n      }\n      setFeedback('');\n      setFeedbackClass('');\n      setQuestionHistory([]);\n    } else {\n      game.startInferenceGame();\n      setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n      setPromptIsHTML(false);\n      setFeedback('');\n      setFeedbackClass('');\n      setLogEntries([]);\n    }\n  }, [mode, game, mazeType, formatQuestionPrompt]);\n\n  const handleHoleClick = useCallback((holeNum) => {\n    if (animating) return;\n\n    if (mode === 'intro') {\n      const result = game.handleIntroAnswer(holeNum, false);\n      if (!result) return;\n      \n      animatePath(\n        result.info.path,\n        result.info.exitHole,\n        result.info.trapped,\n        result.animStartHole,\n        () => {\n          const feedbackResult = result.after();\n          if (feedbackResult) {\n            setFeedback(feedbackResult.feedback);\n            setFeedbackClass(feedbackResult.feedbackClass);\n            \n            if (feedbackResult.isCorrect !== undefined) {\n              // Update score display will happen automatically via game state\n              setTimeout(() => {\n                if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                  // Get next question\n                  game.nextQuestion(game.mapping);\n                  // Question will be set in state, we'll update prompt in useEffect\n                } else {\n                  setPrompt('Game over. You\\'ve answered all 8 questions.');\n                  setPromptIsHTML(false);\n                  // Score is already updated in the hook, but we need to account for the current answer\n                  const finalScore = feedbackResult.isCorrect ? game.score + 1 : game.score;\n                  setFeedback(`You made ${finalScore} out of ${game.TOTAL_QUESTIONS} correct predictions.`);\n                  setFeedbackClass('');\n                }\n                \n                setTimeout(() => {\n                  if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                    setFeedback('');\n                    setFeedbackClass('');\n                  }\n                }, 3000);\n              }, 1800);\n            }\n          }\n        },\n        gridToDraw\n      );\n    } else {\n      const { info, probeCount } = game.handleInferenceProbe(holeNum);\n      animateInferenceProbe(\n        holeNum,\n        info,\n        () => {\n          if (info.trapped) {\n            setFeedback(`The mouse from hole ${holeNum} is stuck in the house forever.`);\n          } else {\n            setFeedback(`The mouse from hole ${holeNum} came out of hole ${info.exitHole}.`);\n          }\n          setFeedbackClass('');\n          const entry = info.trapped\n            ? `From ${holeNum} → (stuck inside)`\n            : `From ${holeNum} → ${info.exitHole}`;\n          setLogEntries(prev => [...prev, entry]);\n        },\n        holeRefs.current\n      );\n    }\n  }, [mode, animating, game, animatePath, animateInferenceProbe, gridToDraw, mazeType, formatQuestionPrompt]);\n\n  const handleNoExitClick = useCallback(() => {\n    if (animating || mode !== 'intro') return;\n    const result = game.handleIntroAnswer(null, true);\n    if (!result) return;\n    \n    animatePath(\n      result.info.path,\n      result.info.exitHole,\n      result.info.trapped,\n      result.animStartHole,\n      () => {\n        const feedbackResult = result.after();\n        if (feedbackResult) {\n          setFeedback(feedbackResult.feedback);\n          setFeedbackClass(feedbackResult.feedbackClass);\n          \n          setTimeout(() => {\n            if (game.questionIndex < game.TOTAL_QUESTIONS) {\n              game.nextQuestion(game.mapping);\n              // Question will be set in state, we'll update prompt in useEffect\n            } else {\n              setPrompt('Game over. You\\'ve answered all 8 questions.');\n              setPromptIsHTML(false);\n              // Score is already updated in the hook, but we need to account for the current answer\n              const finalScore = feedbackResult.isCorrect ? game.score + 1 : game.score;\n              setFeedback(`You made ${finalScore} out of ${game.TOTAL_QUESTIONS} correct predictions.`);\n              setFeedbackClass('');\n            }\n            \n            setTimeout(() => {\n              if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                setFeedback('');\n                setFeedbackClass('');\n              }\n            }, 3000);\n          }, 1800);\n        }\n      },\n      gridToDraw\n    );\n  }, [animating, mode, game, animatePath, gridToDraw, mazeType, formatQuestionPrompt]);\n\n  const handleCanvasClick = useCallback((r, c) => {\n    if (mode !== 'inference' || animating) return;\n    \n    let val = game.modelGrid[r][c];\n    if (mazeType === 'walls') {\n      const seq = ['', '/', '\\\\'];\n      let idx = seq.indexOf(val);\n      if (idx === -1) idx = 0;\n      val = seq[(idx + 1) % seq.length];\n    } else {\n      const seq = ['', 'U', 'R', 'D', 'L'];\n      let idx = seq.indexOf(val);\n      if (idx === -1) idx = 0;\n      val = seq[(idx + 1) % seq.length];\n    }\n    game.updateModelGrid(r, c, val);\n  }, [mode, animating, game, mazeType]);\n\n  const handleTestModel = useCallback(() => {\n    if (mode !== 'inference') return;\n    const result = game.testModel();\n    setFeedback(result.feedback);\n    setFeedbackClass('');\n  }, [mode, game]);\n\n  return (\n    <div className={styles.app}>\n      <h1>Mouse Mazes</h1>\n      <GameControls\n        mode={mode}\n        mazeType={mazeType}\n        level={level}\n        onModeChange={handleModeChange}\n        onMazeTypeChange={handleMazeTypeChange}\n        onLevelChange={handleLevelChange}\n        onNewGame={handleNewGame}\n      />\n      <div className={styles.gameArea}>\n        <GameBoard\n          mode={mode}\n          gridToDraw={gridToDraw}\n          animating={animating}\n          onHoleClick={handleHoleClick}\n          onCanvasClick={handleCanvasClick}\n          mouseMarkerRef={mouseMarkerRef}\n          holeRefs={holeRefs}\n          canvasRef={canvasRef}\n        />\n        <SidePanel\n          mode={mode}\n          mazeType={mazeType}\n          prompt={prompt}\n          promptIsHTML={promptIsHTML}\n          feedback={feedback}\n          feedbackClass={feedbackClass}\n          score={game.score}\n          questionIndex={game.questionIndex}\n          totalQuestions={game.TOTAL_QUESTIONS}\n          onTestModel={handleTestModel}\n          onNoExitClick={handleNoExitClick}\n          logEntries={logEntries}\n          questionHistory={questionHistory}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}