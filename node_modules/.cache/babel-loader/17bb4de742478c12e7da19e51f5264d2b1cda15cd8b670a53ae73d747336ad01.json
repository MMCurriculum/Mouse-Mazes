{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef, useCallback } from 'react';\nimport { holeWallCoords } from '../utils/mazeUtils';\nimport { drawMaze as drawMazeUtil } from '../utils/drawingUtils';\nconst CANVAS_SIZE = 600;\nconst SIZE = 4;\nconst CELL = CANVAS_SIZE / SIZE;\n\n// Cache for the mouse image - preload it\nlet mouseImageCache = null;\n\n// Preload the mouse image\nconst mouseImage = new Image();\nmouseImage.onload = () => {\n  mouseImageCache = mouseImage;\n};\nmouseImage.onerror = () => {\n  console.warn('Failed to load mouse image:', (process.env.PUBLIC_URL || '.') + '/movingmouse.png');\n};\nmouseImage.src = (process.env.PUBLIC_URL || '.') + '/movingmouse.png';\nfunction drawMouseOnCanvas(ctx, x, y, direction) {\n  if (!mouseImageCache) {\n    // Image not loaded yet, skip drawing\n    return;\n  }\n  ctx.save();\n\n  // Move to center point\n  ctx.translate(x, y);\n\n  // Apply transformations based on direction\n  // Image faces right by default\n  if (direction === 'right') {\n    // No transformation needed (already faces right)\n  } else if (direction === 'down') {\n    // Rotate 90 degrees clockwise\n    ctx.rotate(Math.PI / 2);\n  } else if (direction === 'left') {\n    // Flip horizontally to face left\n    ctx.scale(-1, 1);\n  } else if (direction === 'up') {\n    // Rotate 90 degrees counterclockwise\n    ctx.rotate(-Math.PI / 2);\n  }\n\n  // Add shadow effect\n  ctx.shadowColor = \"rgba(0, 0, 0, 0.4)\";\n  ctx.shadowBlur = 3;\n  ctx.shadowOffsetX = 0;\n  ctx.shadowOffsetY = 3;\n\n  // Draw image centered, scaled to 36px (50% of 72px)\n  const imgSize = 36;\n  ctx.drawImage(mouseImageCache, -imgSize / 2, -imgSize / 2, imgSize, imgSize);\n  ctx.restore();\n}\nfunction getDirection(p1, p2) {\n  const dx = p2.x - p1.x;\n  const dy = p2.y - p1.y;\n\n  // Determine primary direction\n  if (Math.abs(dx) > Math.abs(dy)) {\n    return dx > 0 ? 'right' : 'left';\n  } else {\n    return dy > 0 ? 'down' : 'up';\n  }\n}\nexport function useAnimation(ctxRef, canvasRef, drawMaze, mouseMarkerRef) {\n  _s();\n  const [animating, setAnimating] = useState(false);\n  const animationFrameRef = useRef(null);\n  const animatePath = useCallback((path, exitHole, trapped, startHole, after, gridToDraw) => {\n    if (!canvasRef.current) return;\n\n    // Ensure context is set\n    if (!ctxRef.current && canvasRef.current) {\n      ctxRef.current = canvasRef.current.getContext('2d');\n    }\n    if (!ctxRef.current) return;\n    setAnimating(true);\n    const points = [];\n    points.push(holeWallCoords(startHole, CELL, CANVAS_SIZE, CANVAS_SIZE));\n    for (const p of path) {\n      points.push({\n        x: p.c * CELL + CELL / 2,\n        y: p.r * CELL + CELL / 2\n      });\n    }\n    if (!trapped && exitHole !== null && exitHole !== undefined) {\n      points.push(holeWallCoords(exitHole, CELL, CANVAS_SIZE, CANVAS_SIZE));\n    }\n    if (points.length < 2) {\n      setAnimating(false);\n      if (after) after();\n      return;\n    }\n    let segIndex = 0;\n    let frame = 0;\n    const framesPerSeg = 24; // 50% slower than original: 15 * 1.5 = 22.5, rounded to 24\n\n    const step = () => {\n      if (!ctxRef.current || !canvasRef.current) return;\n      drawMazeUtil(ctxRef.current, canvasRef.current, gridToDraw, CELL);\n      ctxRef.current.strokeStyle = \"rgba(255,200,80,0.6)\";\n      ctxRef.current.lineWidth = 6;\n      ctxRef.current.lineCap = \"round\";\n      ctxRef.current.beginPath();\n      let started = false;\n      for (let i = 0; i < segIndex; i++) {\n        const p1 = points[i];\n        const p2 = points[i + 1];\n        if (!started) {\n          ctxRef.current.moveTo(p1.x, p1.y);\n          started = true;\n        }\n        ctxRef.current.lineTo(p2.x, p2.y);\n      }\n      const p1 = points[segIndex];\n      const p2 = points[segIndex + 1];\n      const t = frame / framesPerSeg;\n      const x = p1.x + (p2.x - p1.x) * t;\n      const y = p1.y + (p2.y - p1.y) * t;\n      if (!started) {\n        ctxRef.current.moveTo(p1.x, p1.y);\n        started = true;\n      }\n      ctxRef.current.lineTo(x, y);\n      ctxRef.current.stroke();\n      ctxRef.current.lineWidth = 1;\n\n      // Determine direction and draw mouse facing that direction\n      const direction = getDirection(p1, p2);\n      drawMouseOnCanvas(ctxRef.current, x, y, direction);\n      frame++;\n      if (frame > framesPerSeg) {\n        frame = 0;\n        segIndex++;\n        if (segIndex >= points.length - 1) {\n          setAnimating(false);\n          if (after) after();\n          return;\n        }\n      }\n      animationFrameRef.current = requestAnimationFrame(step);\n    };\n    animationFrameRef.current = requestAnimationFrame(step);\n  }, [ctxRef, canvasRef]);\n  const animateDomSegment = useCallback((p1, p2, callback) => {\n    if (!mouseMarkerRef.current) return;\n    setAnimating(true);\n    const frames = 56; // 25% slower: 45 * 1.25 = 56.25, rounded to 56\n    let frame = 0;\n    mouseMarkerRef.current.style.display = \"block\";\n\n    // Determine direction for this segment\n    const direction = getDirection(p1, p2);\n    let transform = '';\n\n    // Apply transformations based on direction (image faces right by default)\n    if (direction === 'right') {\n      transform = ''; // No transformation needed\n    } else if (direction === 'down') {\n      transform = 'rotate(90deg)'; // Rotate 90 degrees clockwise\n    } else if (direction === 'left') {\n      transform = 'scaleX(-1)'; // Flip horizontally\n    } else if (direction === 'up') {\n      transform = 'rotate(-90deg)'; // Rotate 90 degrees counterclockwise\n    }\n    mouseMarkerRef.current.style.transform = transform;\n    const step = () => {\n      if (!mouseMarkerRef.current) return;\n      const t = frame / frames;\n      const x = p1.x + (p2.x - p1.x) * t;\n      const y = p1.y + (p2.y - p1.y) * t;\n      mouseMarkerRef.current.style.left = x - 18 + \"px\"; // 50% of 36px = 18px\n      mouseMarkerRef.current.style.top = y - 18 + \"px\"; // 50% of 36px = 18px\n\n      frame++;\n      if (frame > frames) {\n        if (callback) callback();\n        return;\n      }\n      animationFrameRef.current = requestAnimationFrame(step);\n    };\n    animationFrameRef.current = requestAnimationFrame(step);\n  }, [mouseMarkerRef]);\n  const animateInferenceProbe = useCallback((startHole, info, after, holeRefs) => {\n    if (!mouseMarkerRef.current) return;\n    const holeStartDiv = holeRefs.find(h => {\n      var _h$dataset;\n      return h && parseInt((_h$dataset = h.dataset) === null || _h$dataset === void 0 ? void 0 : _h$dataset.num) === startHole;\n    });\n    if (!holeStartDiv) {\n      if (after) after();\n      return;\n    }\n    const startBtn = {\n      x: holeStartDiv.offsetLeft + holeStartDiv.offsetWidth / 2,\n      y: holeStartDiv.offsetTop + holeStartDiv.offsetHeight / 2\n    };\n    const startEdgeCanvas = holeWallCoords(startHole, CELL, CANVAS_SIZE, CANVAS_SIZE);\n    const startEdge = {\n      x: startEdgeCanvas.x,\n      y: startEdgeCanvas.y\n    };\n    const doExit = () => {\n      if (info.trapped || info.exitHole === null || info.exitHole === undefined) {\n        if (mouseMarkerRef.current) {\n          mouseMarkerRef.current.style.display = \"none\";\n        }\n        setAnimating(false);\n        if (after) after();\n        return;\n      }\n      const holeExitDiv = holeRefs.find(h => {\n        var _h$dataset2;\n        return h && parseInt((_h$dataset2 = h.dataset) === null || _h$dataset2 === void 0 ? void 0 : _h$dataset2.num) === info.exitHole;\n      });\n      if (!holeExitDiv) {\n        if (mouseMarkerRef.current) {\n          mouseMarkerRef.current.style.display = \"none\";\n        }\n        setAnimating(false);\n        if (after) after();\n        return;\n      }\n      const exitEdgeCanvas = holeWallCoords(info.exitHole, CELL, CANVAS_SIZE, CANVAS_SIZE);\n      const exitEdge = {\n        x: exitEdgeCanvas.x,\n        y: exitEdgeCanvas.y\n      };\n      const exitBtn = {\n        x: holeExitDiv.offsetLeft + holeExitDiv.offsetWidth / 2,\n        y: holeExitDiv.offsetTop + holeExitDiv.offsetHeight / 2\n      };\n      animateDomSegment(exitEdge, exitBtn, () => {\n        if (mouseMarkerRef.current) {\n          mouseMarkerRef.current.style.display = \"none\";\n        }\n        setAnimating(false);\n        if (after) after();\n      });\n    };\n    animateDomSegment(startBtn, startEdge, doExit);\n  }, [mouseMarkerRef, animateDomSegment]);\n\n  // Cleanup on unmount\n  const cleanup = useCallback(() => {\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n  }, []);\n  return {\n    animating,\n    animatePath,\n    animateInferenceProbe,\n    cleanup\n  };\n}\n_s(useAnimation, \"3raidQpeWrmXkQ5GygeZuEYWqQk=\");","map":{"version":3,"names":["useState","useRef","useCallback","holeWallCoords","drawMaze","drawMazeUtil","CANVAS_SIZE","SIZE","CELL","mouseImageCache","mouseImage","Image","onload","onerror","console","warn","process","env","PUBLIC_URL","src","drawMouseOnCanvas","ctx","x","y","direction","save","translate","rotate","Math","PI","scale","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","imgSize","drawImage","restore","getDirection","p1","p2","dx","dy","abs","useAnimation","ctxRef","canvasRef","mouseMarkerRef","_s","animating","setAnimating","animationFrameRef","animatePath","path","exitHole","trapped","startHole","after","gridToDraw","current","getContext","points","push","p","c","r","undefined","length","segIndex","frame","framesPerSeg","step","strokeStyle","lineWidth","lineCap","beginPath","started","i","moveTo","lineTo","t","stroke","requestAnimationFrame","animateDomSegment","callback","frames","style","display","transform","left","top","animateInferenceProbe","info","holeRefs","holeStartDiv","find","h","_h$dataset","parseInt","dataset","num","startBtn","offsetLeft","offsetWidth","offsetTop","offsetHeight","startEdgeCanvas","startEdge","doExit","holeExitDiv","_h$dataset2","exitEdgeCanvas","exitEdge","exitBtn","cleanup","cancelAnimationFrame"],"sources":["/Users/joshuaabrams/Library/CloudStorage/Dropbox/Professional Development Activities & Workshops/*Making Math Website/VariedContent/Geometry/LogicAndReasoning/MouseMazes/mouse-mazes-react/src/hooks/useAnimation.js"],"sourcesContent":["import { useState, useRef, useCallback } from 'react';\nimport { holeWallCoords } from '../utils/mazeUtils';\nimport { drawMaze as drawMazeUtil } from '../utils/drawingUtils';\n\nconst CANVAS_SIZE = 600;\nconst SIZE = 4;\nconst CELL = CANVAS_SIZE / SIZE;\n\n// Cache for the mouse image - preload it\nlet mouseImageCache = null;\n\n// Preload the mouse image\nconst mouseImage = new Image();\nmouseImage.onload = () => {\n  mouseImageCache = mouseImage;\n};\nmouseImage.onerror = () => {\n  console.warn('Failed to load mouse image:', (process.env.PUBLIC_URL || '.') + '/movingmouse.png');\n};\nmouseImage.src = (process.env.PUBLIC_URL || '.') + '/movingmouse.png';\n\nfunction drawMouseOnCanvas(ctx, x, y, direction) {\n  if (!mouseImageCache) {\n    // Image not loaded yet, skip drawing\n    return;\n  }\n  \n  ctx.save();\n  \n  // Move to center point\n  ctx.translate(x, y);\n  \n  // Apply transformations based on direction\n  // Image faces right by default\n  if (direction === 'right') {\n    // No transformation needed (already faces right)\n  } else if (direction === 'down') {\n    // Rotate 90 degrees clockwise\n    ctx.rotate(Math.PI / 2);\n  } else if (direction === 'left') {\n    // Flip horizontally to face left\n    ctx.scale(-1, 1);\n  } else if (direction === 'up') {\n    // Rotate 90 degrees counterclockwise\n    ctx.rotate(-Math.PI / 2);\n  }\n  \n  // Add shadow effect\n  ctx.shadowColor = \"rgba(0, 0, 0, 0.4)\";\n  ctx.shadowBlur = 3;\n  ctx.shadowOffsetX = 0;\n  ctx.shadowOffsetY = 3;\n  \n  // Draw image centered, scaled to 36px (50% of 72px)\n  const imgSize = 36;\n  ctx.drawImage(mouseImageCache, -imgSize / 2, -imgSize / 2, imgSize, imgSize);\n  \n  ctx.restore();\n}\n\nfunction getDirection(p1, p2) {\n  const dx = p2.x - p1.x;\n  const dy = p2.y - p1.y;\n  \n  // Determine primary direction\n  if (Math.abs(dx) > Math.abs(dy)) {\n    return dx > 0 ? 'right' : 'left';\n  } else {\n    return dy > 0 ? 'down' : 'up';\n  }\n}\n\nexport function useAnimation(ctxRef, canvasRef, drawMaze, mouseMarkerRef) {\n  const [animating, setAnimating] = useState(false);\n  const animationFrameRef = useRef(null);\n\n  const animatePath = useCallback((path, exitHole, trapped, startHole, after, gridToDraw) => {\n    if (!canvasRef.current) return;\n    \n    // Ensure context is set\n    if (!ctxRef.current && canvasRef.current) {\n      ctxRef.current = canvasRef.current.getContext('2d');\n    }\n    \n    if (!ctxRef.current) return;\n    \n    setAnimating(true);\n    const points = [];\n    points.push(holeWallCoords(startHole, CELL, CANVAS_SIZE, CANVAS_SIZE));\n    for (const p of path) {\n      points.push({ x: p.c * CELL + CELL / 2, y: p.r * CELL + CELL / 2 });\n    }\n    if (!trapped && exitHole !== null && exitHole !== undefined) {\n      points.push(holeWallCoords(exitHole, CELL, CANVAS_SIZE, CANVAS_SIZE));\n    }\n\n    if (points.length < 2) {\n      setAnimating(false);\n      if (after) after();\n      return;\n    }\n\n    let segIndex = 0;\n    let frame = 0;\n    const framesPerSeg = 24; // 50% slower than original: 15 * 1.5 = 22.5, rounded to 24\n\n    const step = () => {\n      if (!ctxRef.current || !canvasRef.current) return;\n      \n      drawMazeUtil(ctxRef.current, canvasRef.current, gridToDraw, CELL);\n\n      ctxRef.current.strokeStyle = \"rgba(255,200,80,0.6)\";\n      ctxRef.current.lineWidth = 6;\n      ctxRef.current.lineCap = \"round\";\n      ctxRef.current.beginPath();\n      let started = false;\n      for (let i = 0; i < segIndex; i++) {\n        const p1 = points[i];\n        const p2 = points[i+1];\n        if (!started) {\n          ctxRef.current.moveTo(p1.x, p1.y);\n          started = true;\n        }\n        ctxRef.current.lineTo(p2.x, p2.y);\n      }\n      const p1 = points[segIndex];\n      const p2 = points[segIndex+1];\n      const t = frame / framesPerSeg;\n      const x = p1.x + (p2.x - p1.x) * t;\n      const y = p1.y + (p2.y - p1.y) * t;\n      if (!started) {\n        ctxRef.current.moveTo(p1.x, p1.y);\n        started = true;\n      }\n      ctxRef.current.lineTo(x, y);\n      ctxRef.current.stroke();\n      ctxRef.current.lineWidth = 1;\n\n      // Determine direction and draw mouse facing that direction\n      const direction = getDirection(p1, p2);\n      drawMouseOnCanvas(ctxRef.current, x, y, direction);\n\n      frame++;\n      if (frame > framesPerSeg) {\n        frame = 0;\n        segIndex++;\n        if (segIndex >= points.length - 1) {\n          setAnimating(false);\n          if (after) after();\n          return;\n        }\n      }\n      animationFrameRef.current = requestAnimationFrame(step);\n    };\n    \n    animationFrameRef.current = requestAnimationFrame(step);\n  }, [ctxRef, canvasRef]);\n\n  const animateDomSegment = useCallback((p1, p2, callback) => {\n    if (!mouseMarkerRef.current) return;\n    \n    setAnimating(true);\n    const frames = 56; // 25% slower: 45 * 1.25 = 56.25, rounded to 56\n    let frame = 0;\n    mouseMarkerRef.current.style.display = \"block\";\n    \n    // Determine direction for this segment\n    const direction = getDirection(p1, p2);\n    let transform = '';\n    \n    // Apply transformations based on direction (image faces right by default)\n    if (direction === 'right') {\n      transform = ''; // No transformation needed\n    } else if (direction === 'down') {\n      transform = 'rotate(90deg)'; // Rotate 90 degrees clockwise\n    } else if (direction === 'left') {\n      transform = 'scaleX(-1)'; // Flip horizontally\n    } else if (direction === 'up') {\n      transform = 'rotate(-90deg)'; // Rotate 90 degrees counterclockwise\n    }\n    \n    mouseMarkerRef.current.style.transform = transform;\n\n    const step = () => {\n      if (!mouseMarkerRef.current) return;\n      \n      const t = frame / frames;\n      const x = p1.x + (p2.x - p1.x) * t;\n      const y = p1.y + (p2.y - p1.y) * t;\n      mouseMarkerRef.current.style.left = (x - 18) + \"px\"; // 50% of 36px = 18px\n      mouseMarkerRef.current.style.top = (y - 18) + \"px\"; // 50% of 36px = 18px\n\n      frame++;\n      if (frame > frames) {\n        if (callback) callback();\n        return;\n      }\n      animationFrameRef.current = requestAnimationFrame(step);\n    };\n    \n    animationFrameRef.current = requestAnimationFrame(step);\n  }, [mouseMarkerRef]);\n\n  const animateInferenceProbe = useCallback((startHole, info, after, holeRefs) => {\n    if (!mouseMarkerRef.current) return;\n    \n    const holeStartDiv = holeRefs.find(h => h && parseInt(h.dataset?.num) === startHole);\n    if (!holeStartDiv) {\n      if (after) after();\n      return;\n    }\n    \n    const startBtn = {\n      x: holeStartDiv.offsetLeft + holeStartDiv.offsetWidth / 2,\n      y: holeStartDiv.offsetTop + holeStartDiv.offsetHeight / 2\n    };\n    const startEdgeCanvas = holeWallCoords(startHole, CELL, CANVAS_SIZE, CANVAS_SIZE);\n    const startEdge = { x: startEdgeCanvas.x, y: startEdgeCanvas.y };\n\n    const doExit = () => {\n      if (info.trapped || info.exitHole === null || info.exitHole === undefined) {\n        if (mouseMarkerRef.current) {\n          mouseMarkerRef.current.style.display = \"none\";\n        }\n        setAnimating(false);\n        if (after) after();\n        return;\n      }\n      const holeExitDiv = holeRefs.find(h => h && parseInt(h.dataset?.num) === info.exitHole);\n      if (!holeExitDiv) {\n        if (mouseMarkerRef.current) {\n          mouseMarkerRef.current.style.display = \"none\";\n        }\n        setAnimating(false);\n        if (after) after();\n        return;\n      }\n      const exitEdgeCanvas = holeWallCoords(info.exitHole, CELL, CANVAS_SIZE, CANVAS_SIZE);\n      const exitEdge = { x: exitEdgeCanvas.x, y: exitEdgeCanvas.y };\n      const exitBtn = {\n        x: holeExitDiv.offsetLeft + holeExitDiv.offsetWidth / 2,\n        y: holeExitDiv.offsetTop + holeExitDiv.offsetHeight / 2\n      };\n      animateDomSegment(exitEdge, exitBtn, () => {\n        if (mouseMarkerRef.current) {\n          mouseMarkerRef.current.style.display = \"none\";\n        }\n        setAnimating(false);\n        if (after) after();\n      });\n    };\n\n    animateDomSegment(startBtn, startEdge, doExit);\n  }, [mouseMarkerRef, animateDomSegment]);\n\n  // Cleanup on unmount\n  const cleanup = useCallback(() => {\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n  }, []);\n\n  return { animating, animatePath, animateInferenceProbe, cleanup };\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}