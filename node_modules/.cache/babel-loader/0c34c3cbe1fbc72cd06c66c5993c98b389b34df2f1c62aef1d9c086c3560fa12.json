{"ast":null,"code":"var _jsxFileName = \"/Users/joshuaabrams/Library/CloudStorage/Dropbox/Professional Development Activities & Workshops/*Making Math Website/VariedContent/Geometry/LogicAndReasoning/MouseMazes/mouse-mazes-react/src/App.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useCallback, useRef, useEffect } from 'react';\nimport { GameControls } from './components/GameControls/GameControls';\nimport { GameBoard } from './components/GameBoard/GameBoard';\nimport { SidePanel } from './components/SidePanel/SidePanel';\nimport { useMazeGame } from './hooks/useMazeGame';\nimport { useMazeCanvas } from './hooks/useMazeCanvas';\nimport { useAnimation } from './hooks/useAnimation';\nimport { emptyGrid, simulateHoleWithGrid, computeMappingForGrid } from './utils/mazeUtils';\nimport styles from './App.module.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [mode, setMode] = useState('intro');\n  const [mazeType, setMazeType] = useState('walls');\n  const [level, setLevel] = useState('beginner');\n  const [prompt, setPrompt] = useState('Click \"Start New Game\" to begin.\\nIn Introduction mode, you\\'ll get 8 questions on the same maze.\\nIn Inference mode, you\\'ll probe the maze and build your own model.');\n  const [promptIsHTML, setPromptIsHTML] = useState(false);\n  const [feedback, setFeedback] = useState('');\n  const [feedbackClass, setFeedbackClass] = useState('');\n  const [logEntries, setLogEntries] = useState([]);\n  const [questionHistory, setQuestionHistory] = useState([]);\n  const [showHiddenModel, setShowHiddenModel] = useState(false);\n  const [modelDidNotMatch, setModelDidNotMatch] = useState(false);\n  const mouseMarkerRef = useRef(null);\n  const holeRefs = useRef([]);\n  const game = useMazeGame(mazeType, level, mode);\n  const gridToDraw = mode === 'intro' ? game.realGrid : game.modelGrid;\n  const hiddenGrid = mode === 'inference' && showHiddenModel ? game.realGrid : null;\n  const {\n    canvasRef,\n    ctxRef,\n    drawMaze\n  } = useMazeCanvas(gridToDraw, hiddenGrid);\n  const {\n    animating,\n    animatePath,\n    animateInferenceProbe\n  } = useAnimation(ctxRef, canvasRef, drawMaze, mouseMarkerRef);\n  const formatQuestionPrompt = useCallback((question, questionIndex, totalQuestions, mazeType, toggleIntroColor) => {\n    const color = toggleIntroColor() ? \"#e67e22\" : \"#1f6ad3\";\n    let scenarioLine = \"\";\n    let rest = \"\";\n    if (question.mode === \"forward\") {\n      scenarioLine = `A mouse leaves hole ${question.startHole}.`;\n      const extra = mazeType === \"arrows\" ? ' (You can also choose \"The Mouse Doesn\\'t Come Out!\")' : \"\";\n      rest = `Where will it come out? Click a hole.${extra}`;\n    } else if (question.mode === \"reverseWalls\") {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"From which hole did it start? Click a starting hole.\";\n    } else {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"Click on one hole that could have been its starting hole.\";\n    }\n    return `Question ${questionIndex} of ${totalQuestions}:<br>` + `<span style=\"font-weight:bold;color:${color};\">${scenarioLine}</span><br>` + `${rest}`;\n  }, []);\n  const formatQuestionForLog = useCallback((question, questionIndex, mazeType) => {\n    let scenarioLine = \"\";\n    let rest = \"\";\n    if (question.mode === \"forward\") {\n      scenarioLine = `A mouse leaves hole ${question.startHole}.`;\n      rest = \"Where will it come out?\";\n    } else if (question.mode === \"reverseWalls\") {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"From which hole did it start?\";\n    } else {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"Click on one hole that could have been its starting hole.\";\n    }\n    return `${scenarioLine} ${rest}`;\n  }, []);\n\n  // Track previous question to add to log when new question appears\n  const prevQuestionRef = useRef(null);\n  const prevQuestionIndexRef = useRef(0);\n\n  // Update prompt when mode changes\n  useEffect(() => {\n    if (mode === 'intro') {\n      setPrompt('Introduction mode:\\nClick \"Start New Game\" to get 8 questions on the same maze.\\nAnswer by clicking a hole (or \"The Mouse Doesn\\'t Come Out!\" when appropriate).');\n      setPromptIsHTML(false);\n    } else {\n      setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n      setPromptIsHTML(false);\n    }\n    setFeedback('');\n    setFeedbackClass('');\n    setQuestionHistory([]);\n    prevQuestionRef.current = null;\n    prevQuestionIndexRef.current = 0;\n    setShowHiddenModel(false);\n    setModelDidNotMatch(false);\n  }, [mode]);\n\n  // Update prompt when question changes\n  useEffect(() => {\n    if (mode === 'intro' && game.currentQuestion && game.questionIndex > 0 && game.questionIndex <= game.TOTAL_QUESTIONS && game.toggleIntroColor) {\n      // If we have a previous question and the index increased, add it to the log\n      if (prevQuestionRef.current && game.questionIndex > prevQuestionIndexRef.current) {\n        const questionText = formatQuestionForLog(prevQuestionRef.current, prevQuestionIndexRef.current, mazeType);\n        setQuestionHistory(prev => [...prev, {\n          questionNumber: prevQuestionIndexRef.current,\n          questionText: questionText\n        }]);\n      }\n      setPrompt(formatQuestionPrompt(game.currentQuestion, game.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n      setPromptIsHTML(true);\n\n      // Update refs for next time\n      prevQuestionRef.current = game.currentQuestion;\n      prevQuestionIndexRef.current = game.questionIndex;\n    }\n  }, [game.currentQuestion, game.questionIndex, mode, mazeType, formatQuestionPrompt, formatQuestionForLog, game.TOTAL_QUESTIONS]);\n  const handleModeChange = useCallback(newMode => {\n    setMode(newMode);\n  }, []);\n  const handleMazeTypeChange = useCallback(newMazeType => {\n    setMazeType(newMazeType);\n  }, []);\n\n  // Automatically start new game when maze type changes\n  const prevMazeTypeRef = useRef(mazeType);\n  const isInitialMountRef = useRef(true);\n  useEffect(() => {\n    // Skip on initial mount\n    if (isInitialMountRef.current) {\n      isInitialMountRef.current = false;\n      prevMazeTypeRef.current = mazeType;\n      return;\n    }\n\n    // Only trigger if maze type actually changed\n    if (prevMazeTypeRef.current !== mazeType) {\n      // Start new game automatically\n      if (mode === 'intro') {\n        const result = game.startIntroGame();\n        if (result && result.question && game.toggleIntroColor) {\n          setPrompt(formatQuestionPrompt(result.question, result.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n          setPromptIsHTML(true);\n          prevQuestionRef.current = result.question;\n          prevQuestionIndexRef.current = result.questionIndex;\n        }\n        setFeedback('');\n        setFeedbackClass('');\n        setQuestionHistory([]);\n      } else {\n        game.startInferenceGame();\n        setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n        setPromptIsHTML(false);\n        setFeedback('');\n        setFeedbackClass('');\n        setLogEntries([]);\n        prevQuestionRef.current = null;\n        prevQuestionIndexRef.current = 0;\n      }\n      // Reset hidden model display when maze type changes\n      setShowHiddenModel(false);\n      setModelDidNotMatch(false);\n    }\n    prevMazeTypeRef.current = mazeType;\n  }, [mazeType, mode, game, formatQuestionPrompt]);\n  const handleLevelChange = useCallback(newLevel => {\n    setLevel(newLevel);\n  }, []);\n  const handleNewGame = useCallback(() => {\n    if (mode === 'intro') {\n      const result = game.startIntroGame();\n      if (result && result.question && game.toggleIntroColor) {\n        setPrompt(formatQuestionPrompt(result.question, result.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n        setPromptIsHTML(true);\n        prevQuestionRef.current = result.question;\n        prevQuestionIndexRef.current = result.questionIndex;\n      }\n      setFeedback('');\n      setFeedbackClass('');\n      setQuestionHistory([]);\n      setModelDidNotMatch(false);\n      setShowHiddenModel(false);\n    } else {\n      game.startInferenceGame();\n      setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n      setPromptIsHTML(false);\n      setFeedback('');\n      setFeedbackClass('');\n      setLogEntries([]);\n      prevQuestionRef.current = null;\n      prevQuestionIndexRef.current = 0;\n      setShowHiddenModel(false);\n      setModelDidNotMatch(false);\n    }\n  }, [mode, game, mazeType, formatQuestionPrompt]);\n  const handleHoleClick = useCallback(holeNum => {\n    if (animating) return;\n    if (mode === 'intro') {\n      const result = game.handleIntroAnswer(holeNum, false);\n      if (!result) return;\n      animatePath(result.info.path, result.info.exitHole, result.info.trapped, result.animStartHole, () => {\n        const feedbackResult = result.after();\n        if (feedbackResult) {\n          setFeedback(feedbackResult.feedback);\n          setFeedbackClass(feedbackResult.feedbackClass);\n          if (feedbackResult.isCorrect !== undefined) {\n            // Update score display will happen automatically via game state\n            setTimeout(() => {\n              if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                // Get next question\n                game.nextQuestion(game.mapping);\n                // Question will be set in state, we'll update prompt in useEffect\n              } else {\n                setPrompt('Game over. You\\'ve answered all 8 questions.');\n                setPromptIsHTML(false);\n                // Score is already updated in the hook, but we need to account for the current answer\n                const finalScore = feedbackResult.isCorrect ? game.score + 1 : game.score;\n                setFeedback(`You made ${finalScore} out of ${game.TOTAL_QUESTIONS} correct predictions.`);\n                setFeedbackClass('');\n              }\n              setTimeout(() => {\n                if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                  setFeedback('');\n                  setFeedbackClass('');\n                }\n              }, 3000);\n            }, 1800);\n          }\n        }\n      }, gridToDraw);\n    } else {\n      const {\n        info,\n        probeCount\n      } = game.handleInferenceProbe(holeNum);\n      animateInferenceProbe(holeNum, info, () => {\n        if (info.trapped) {\n          setFeedback(`The mouse from hole ${holeNum} is stuck in the house forever.`);\n        } else {\n          setFeedback(`The mouse from hole ${holeNum} came out of hole ${info.exitHole}.`);\n        }\n        setFeedbackClass('');\n        const entry = info.trapped ? `From ${holeNum} → (stuck inside)` : `From ${holeNum} → ${info.exitHole}`;\n        setLogEntries(prev => [...prev, entry]);\n      }, holeRefs.current);\n    }\n  }, [mode, animating, game, animatePath, animateInferenceProbe, gridToDraw, mazeType, formatQuestionPrompt]);\n  const handleNoExitClick = useCallback(() => {\n    if (animating || mode !== 'intro') return;\n    const result = game.handleIntroAnswer(null, true);\n    if (!result) return;\n    animatePath(result.info.path, result.info.exitHole, result.info.trapped, result.animStartHole, () => {\n      const feedbackResult = result.after();\n      if (feedbackResult) {\n        setFeedback(feedbackResult.feedback);\n        setFeedbackClass(feedbackResult.feedbackClass);\n        setTimeout(() => {\n          if (game.questionIndex < game.TOTAL_QUESTIONS) {\n            game.nextQuestion(game.mapping);\n            // Question will be set in state, we'll update prompt in useEffect\n          } else {\n            setPrompt('Game over. You\\'ve answered all 8 questions.');\n            setPromptIsHTML(false);\n            // Score is already updated in the hook, but we need to account for the current answer\n            const finalScore = feedbackResult.isCorrect ? game.score + 1 : game.score;\n            setFeedback(`You made ${finalScore} out of ${game.TOTAL_QUESTIONS} correct predictions.`);\n            setFeedbackClass('');\n          }\n          setTimeout(() => {\n            if (game.questionIndex < game.TOTAL_QUESTIONS) {\n              setFeedback('');\n              setFeedbackClass('');\n            }\n          }, 3000);\n        }, 1800);\n      }\n    }, gridToDraw);\n  }, [animating, mode, game, animatePath, gridToDraw, mazeType, formatQuestionPrompt]);\n  const handleCanvasClick = useCallback((r, c) => {\n    if (mode !== 'inference' || animating) return;\n\n    // If showing hidden model, switch back to user's model when they edit\n    if (showHiddenModel) {\n      setShowHiddenModel(false);\n    }\n    let val = game.modelGrid[r][c];\n    if (mazeType === 'walls') {\n      const seq = ['', '/', '\\\\'];\n      let idx = seq.indexOf(val);\n      if (idx === -1) idx = 0;\n      val = seq[(idx + 1) % seq.length];\n    } else {\n      const seq = ['', 'U', 'R', 'D', 'L'];\n      let idx = seq.indexOf(val);\n      if (idx === -1) idx = 0;\n      val = seq[(idx + 1) % seq.length];\n    }\n    game.updateModelGrid(r, c, val);\n  }, [mode, animating, game, mazeType, showHiddenModel]);\n  const handleTestModel = useCallback(() => {\n    if (mode !== 'inference') return;\n    const result = game.testModel();\n    console.log('handleTestModel result:', result);\n    setFeedback(result.feedback);\n    setFeedbackClass('');\n    // Show \"Show Hidden Model\" button if model didn't match perfectly\n    const shouldShowButton = result.didNotMatch === true;\n    console.log('shouldShowButton:', shouldShowButton, 'result.didNotMatch:', result.didNotMatch);\n    setModelDidNotMatch(shouldShowButton);\n    // Reset show hidden model when testing again\n    setShowHiddenModel(false);\n  }, [mode, game]);\n  const handleShowHiddenModel = useCallback(() => {\n    setShowHiddenModel(true);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: styles.app,\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.header,\n      children: [/*#__PURE__*/_jsxDEV(\"img\", {\n        src: (process.env.PUBLIC_URL || '.') + '/MouseInAHole.png',\n        alt: \"Mouse Mazes Logo\",\n        className: styles.logo\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 359,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"h1\", {\n        className: styles.title,\n        children: \"Mouse Mazes\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 364,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 358,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(GameControls, {\n      mode: mode,\n      mazeType: mazeType,\n      level: level,\n      onModeChange: handleModeChange,\n      onMazeTypeChange: handleMazeTypeChange,\n      onLevelChange: handleLevelChange,\n      onNewGame: handleNewGame\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 366,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.gameArea,\n      children: [/*#__PURE__*/_jsxDEV(GameBoard, {\n        mode: mode,\n        gridToDraw: gridToDraw,\n        animating: animating,\n        onHoleClick: handleHoleClick,\n        onCanvasClick: handleCanvasClick,\n        mouseMarkerRef: mouseMarkerRef,\n        holeRefs: holeRefs,\n        canvasRef: canvasRef\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 376,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(SidePanel, {\n        mode: mode,\n        mazeType: mazeType,\n        prompt: prompt,\n        promptIsHTML: promptIsHTML,\n        feedback: feedback,\n        feedbackClass: feedbackClass,\n        score: game.score,\n        questionIndex: game.questionIndex,\n        totalQuestions: game.TOTAL_QUESTIONS,\n        onTestModel: handleTestModel,\n        onNoExitClick: handleNoExitClick,\n        logEntries: logEntries,\n        questionHistory: questionHistory,\n        onShowHiddenModel: handleShowHiddenModel,\n        showHiddenModelButton: (() => {\n          const shouldShow = modelDidNotMatch && !showHiddenModel;\n          console.log('SidePanel prop calculation - modelDidNotMatch:', modelDidNotMatch, 'showHiddenModel:', showHiddenModel, 'shouldShow:', shouldShow);\n          return shouldShow;\n        })()\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 386,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 375,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 357,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"EhhUkD6H/RceyQS2UbsP33wiI2E=\", false, function () {\n  return [useMazeGame, useMazeCanvas, useAnimation];\n});\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useCallback","useRef","useEffect","GameControls","GameBoard","SidePanel","useMazeGame","useMazeCanvas","useAnimation","emptyGrid","simulateHoleWithGrid","computeMappingForGrid","styles","jsxDEV","_jsxDEV","App","_s","mode","setMode","mazeType","setMazeType","level","setLevel","prompt","setPrompt","promptIsHTML","setPromptIsHTML","feedback","setFeedback","feedbackClass","setFeedbackClass","logEntries","setLogEntries","questionHistory","setQuestionHistory","showHiddenModel","setShowHiddenModel","modelDidNotMatch","setModelDidNotMatch","mouseMarkerRef","holeRefs","game","gridToDraw","realGrid","modelGrid","hiddenGrid","canvasRef","ctxRef","drawMaze","animating","animatePath","animateInferenceProbe","formatQuestionPrompt","question","questionIndex","totalQuestions","toggleIntroColor","color","scenarioLine","rest","startHole","extra","endHole","formatQuestionForLog","prevQuestionRef","prevQuestionIndexRef","current","currentQuestion","TOTAL_QUESTIONS","questionText","prev","questionNumber","handleModeChange","newMode","handleMazeTypeChange","newMazeType","prevMazeTypeRef","isInitialMountRef","result","startIntroGame","startInferenceGame","handleLevelChange","newLevel","handleNewGame","handleHoleClick","holeNum","handleIntroAnswer","info","path","exitHole","trapped","animStartHole","feedbackResult","after","isCorrect","undefined","setTimeout","nextQuestion","mapping","finalScore","score","probeCount","handleInferenceProbe","entry","handleNoExitClick","handleCanvasClick","r","c","val","seq","idx","indexOf","length","updateModelGrid","handleTestModel","testModel","console","log","shouldShowButton","didNotMatch","handleShowHiddenModel","className","app","children","header","src","process","env","PUBLIC_URL","alt","logo","fileName","_jsxFileName","lineNumber","columnNumber","title","onModeChange","onMazeTypeChange","onLevelChange","onNewGame","gameArea","onHoleClick","onCanvasClick","onTestModel","onNoExitClick","onShowHiddenModel","showHiddenModelButton","shouldShow","_c","$RefreshReg$"],"sources":["/Users/joshuaabrams/Library/CloudStorage/Dropbox/Professional Development Activities & Workshops/*Making Math Website/VariedContent/Geometry/LogicAndReasoning/MouseMazes/mouse-mazes-react/src/App.jsx"],"sourcesContent":["import React, { useState, useCallback, useRef, useEffect } from 'react';\nimport { GameControls } from './components/GameControls/GameControls';\nimport { GameBoard } from './components/GameBoard/GameBoard';\nimport { SidePanel } from './components/SidePanel/SidePanel';\nimport { useMazeGame } from './hooks/useMazeGame';\nimport { useMazeCanvas } from './hooks/useMazeCanvas';\nimport { useAnimation } from './hooks/useAnimation';\nimport { emptyGrid, simulateHoleWithGrid, computeMappingForGrid } from './utils/mazeUtils';\nimport styles from './App.module.css';\n\nfunction App() {\n  const [mode, setMode] = useState('intro');\n  const [mazeType, setMazeType] = useState('walls');\n  const [level, setLevel] = useState('beginner');\n  const [prompt, setPrompt] = useState('Click \"Start New Game\" to begin.\\nIn Introduction mode, you\\'ll get 8 questions on the same maze.\\nIn Inference mode, you\\'ll probe the maze and build your own model.');\n  const [promptIsHTML, setPromptIsHTML] = useState(false);\n  const [feedback, setFeedback] = useState('');\n  const [feedbackClass, setFeedbackClass] = useState('');\n  const [logEntries, setLogEntries] = useState([]);\n  const [questionHistory, setQuestionHistory] = useState([]);\n  const [showHiddenModel, setShowHiddenModel] = useState(false);\n  const [modelDidNotMatch, setModelDidNotMatch] = useState(false);\n  \n  const mouseMarkerRef = useRef(null);\n  const holeRefs = useRef([]);\n  \n  const game = useMazeGame(mazeType, level, mode);\n  const gridToDraw = mode === 'intro' ? game.realGrid : game.modelGrid;\n  const hiddenGrid = mode === 'inference' && showHiddenModel ? game.realGrid : null;\n  const { canvasRef, ctxRef, drawMaze } = useMazeCanvas(gridToDraw, hiddenGrid);\n  const { animating, animatePath, animateInferenceProbe } = useAnimation(\n    ctxRef,\n    canvasRef,\n    drawMaze,\n    mouseMarkerRef\n  );\n\n  const formatQuestionPrompt = useCallback((question, questionIndex, totalQuestions, mazeType, toggleIntroColor) => {\n    const color = toggleIntroColor() ? \"#e67e22\" : \"#1f6ad3\";\n    let scenarioLine = \"\";\n    let rest = \"\";\n\n    if (question.mode === \"forward\") {\n      scenarioLine = `A mouse leaves hole ${question.startHole}.`;\n      const extra = (mazeType === \"arrows\")\n        ? ' (You can also choose \"The Mouse Doesn\\'t Come Out!\")'\n        : \"\";\n      rest = `Where will it come out? Click a hole.${extra}`;\n    } else if (question.mode === \"reverseWalls\") {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"From which hole did it start? Click a starting hole.\";\n    } else {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"Click on one hole that could have been its starting hole.\";\n    }\n\n    return `Question ${questionIndex} of ${totalQuestions}:<br>` +\n      `<span style=\"font-weight:bold;color:${color};\">${scenarioLine}</span><br>` +\n      `${rest}`;\n  }, []);\n\n  const formatQuestionForLog = useCallback((question, questionIndex, mazeType) => {\n    let scenarioLine = \"\";\n    let rest = \"\";\n\n    if (question.mode === \"forward\") {\n      scenarioLine = `A mouse leaves hole ${question.startHole}.`;\n      rest = \"Where will it come out?\";\n    } else if (question.mode === \"reverseWalls\") {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"From which hole did it start?\";\n    } else {\n      scenarioLine = `A mouse ends up in hole ${question.endHole}.`;\n      rest = \"Click on one hole that could have been its starting hole.\";\n    }\n\n    return `${scenarioLine} ${rest}`;\n  }, []);\n\n  // Track previous question to add to log when new question appears\n  const prevQuestionRef = useRef(null);\n  const prevQuestionIndexRef = useRef(0);\n\n  // Update prompt when mode changes\n  useEffect(() => {\n    if (mode === 'intro') {\n      setPrompt('Introduction mode:\\nClick \"Start New Game\" to get 8 questions on the same maze.\\nAnswer by clicking a hole (or \"The Mouse Doesn\\'t Come Out!\" when appropriate).');\n      setPromptIsHTML(false);\n    } else {\n      setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n      setPromptIsHTML(false);\n    }\n    setFeedback('');\n    setFeedbackClass('');\n    setQuestionHistory([]);\n    prevQuestionRef.current = null;\n    prevQuestionIndexRef.current = 0;\n    setShowHiddenModel(false);\n    setModelDidNotMatch(false);\n  }, [mode]);\n\n  // Update prompt when question changes\n  useEffect(() => {\n    if (mode === 'intro' && game.currentQuestion && game.questionIndex > 0 && game.questionIndex <= game.TOTAL_QUESTIONS && game.toggleIntroColor) {\n      // If we have a previous question and the index increased, add it to the log\n      if (prevQuestionRef.current && game.questionIndex > prevQuestionIndexRef.current) {\n        const questionText = formatQuestionForLog(prevQuestionRef.current, prevQuestionIndexRef.current, mazeType);\n        setQuestionHistory(prev => [...prev, {\n          questionNumber: prevQuestionIndexRef.current,\n          questionText: questionText\n        }]);\n      }\n      \n      setPrompt(formatQuestionPrompt(game.currentQuestion, game.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n      setPromptIsHTML(true);\n      \n      // Update refs for next time\n      prevQuestionRef.current = game.currentQuestion;\n      prevQuestionIndexRef.current = game.questionIndex;\n    }\n  }, [game.currentQuestion, game.questionIndex, mode, mazeType, formatQuestionPrompt, formatQuestionForLog, game.TOTAL_QUESTIONS]);\n\n  const handleModeChange = useCallback((newMode) => {\n    setMode(newMode);\n  }, []);\n\n  const handleMazeTypeChange = useCallback((newMazeType) => {\n    setMazeType(newMazeType);\n  }, []);\n\n  // Automatically start new game when maze type changes\n  const prevMazeTypeRef = useRef(mazeType);\n  const isInitialMountRef = useRef(true);\n  useEffect(() => {\n    // Skip on initial mount\n    if (isInitialMountRef.current) {\n      isInitialMountRef.current = false;\n      prevMazeTypeRef.current = mazeType;\n      return;\n    }\n    \n    // Only trigger if maze type actually changed\n    if (prevMazeTypeRef.current !== mazeType) {\n      // Start new game automatically\n      if (mode === 'intro') {\n        const result = game.startIntroGame();\n        if (result && result.question && game.toggleIntroColor) {\n          setPrompt(formatQuestionPrompt(result.question, result.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n          setPromptIsHTML(true);\n          prevQuestionRef.current = result.question;\n          prevQuestionIndexRef.current = result.questionIndex;\n        }\n        setFeedback('');\n        setFeedbackClass('');\n        setQuestionHistory([]);\n      } else {\n        game.startInferenceGame();\n        setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n        setPromptIsHTML(false);\n        setFeedback('');\n        setFeedbackClass('');\n        setLogEntries([]);\n        prevQuestionRef.current = null;\n        prevQuestionIndexRef.current = 0;\n      }\n      // Reset hidden model display when maze type changes\n      setShowHiddenModel(false);\n      setModelDidNotMatch(false);\n    }\n    prevMazeTypeRef.current = mazeType;\n  }, [mazeType, mode, game, formatQuestionPrompt]);\n\n  const handleLevelChange = useCallback((newLevel) => {\n    setLevel(newLevel);\n  }, []);\n\n  const handleNewGame = useCallback(() => {\n    if (mode === 'intro') {\n      const result = game.startIntroGame();\n      if (result && result.question && game.toggleIntroColor) {\n        setPrompt(formatQuestionPrompt(result.question, result.questionIndex, game.TOTAL_QUESTIONS, mazeType, game.toggleIntroColor));\n        setPromptIsHTML(true);\n        prevQuestionRef.current = result.question;\n        prevQuestionIndexRef.current = result.questionIndex;\n      }\n      setFeedback('');\n      setFeedbackClass('');\n      setQuestionHistory([]);\n      setModelDidNotMatch(false);\n      setShowHiddenModel(false);\n    } else {\n      game.startInferenceGame();\n      setPrompt('Inference mode:\\nClick mouse holes to probe the hidden maze (log appears below).\\nClick inside rooms to set your model (blank / wall / arrow).\\nWhen you\\'re ready, press \"Test My Model\".');\n      setPromptIsHTML(false);\n      setFeedback('');\n      setFeedbackClass('');\n      setLogEntries([]);\n      prevQuestionRef.current = null;\n      prevQuestionIndexRef.current = 0;\n      setShowHiddenModel(false);\n      setModelDidNotMatch(false);\n    }\n  }, [mode, game, mazeType, formatQuestionPrompt]);\n\n  const handleHoleClick = useCallback((holeNum) => {\n    if (animating) return;\n\n    if (mode === 'intro') {\n      const result = game.handleIntroAnswer(holeNum, false);\n      if (!result) return;\n      \n      animatePath(\n        result.info.path,\n        result.info.exitHole,\n        result.info.trapped,\n        result.animStartHole,\n        () => {\n          const feedbackResult = result.after();\n          if (feedbackResult) {\n            setFeedback(feedbackResult.feedback);\n            setFeedbackClass(feedbackResult.feedbackClass);\n            \n            if (feedbackResult.isCorrect !== undefined) {\n              // Update score display will happen automatically via game state\n              setTimeout(() => {\n                if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                  // Get next question\n                  game.nextQuestion(game.mapping);\n                  // Question will be set in state, we'll update prompt in useEffect\n                } else {\n                  setPrompt('Game over. You\\'ve answered all 8 questions.');\n                  setPromptIsHTML(false);\n                  // Score is already updated in the hook, but we need to account for the current answer\n                  const finalScore = feedbackResult.isCorrect ? game.score + 1 : game.score;\n                  setFeedback(`You made ${finalScore} out of ${game.TOTAL_QUESTIONS} correct predictions.`);\n                  setFeedbackClass('');\n                }\n                \n                setTimeout(() => {\n                  if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                    setFeedback('');\n                    setFeedbackClass('');\n                  }\n                }, 3000);\n              }, 1800);\n            }\n          }\n        },\n        gridToDraw\n      );\n    } else {\n      const { info, probeCount } = game.handleInferenceProbe(holeNum);\n      animateInferenceProbe(\n        holeNum,\n        info,\n        () => {\n          if (info.trapped) {\n            setFeedback(`The mouse from hole ${holeNum} is stuck in the house forever.`);\n          } else {\n            setFeedback(`The mouse from hole ${holeNum} came out of hole ${info.exitHole}.`);\n          }\n          setFeedbackClass('');\n          const entry = info.trapped\n            ? `From ${holeNum} → (stuck inside)`\n            : `From ${holeNum} → ${info.exitHole}`;\n          setLogEntries(prev => [...prev, entry]);\n        },\n        holeRefs.current\n      );\n    }\n  }, [mode, animating, game, animatePath, animateInferenceProbe, gridToDraw, mazeType, formatQuestionPrompt]);\n\n  const handleNoExitClick = useCallback(() => {\n    if (animating || mode !== 'intro') return;\n    const result = game.handleIntroAnswer(null, true);\n    if (!result) return;\n    \n    animatePath(\n      result.info.path,\n      result.info.exitHole,\n      result.info.trapped,\n      result.animStartHole,\n      () => {\n        const feedbackResult = result.after();\n        if (feedbackResult) {\n          setFeedback(feedbackResult.feedback);\n          setFeedbackClass(feedbackResult.feedbackClass);\n          \n          setTimeout(() => {\n            if (game.questionIndex < game.TOTAL_QUESTIONS) {\n              game.nextQuestion(game.mapping);\n              // Question will be set in state, we'll update prompt in useEffect\n            } else {\n              setPrompt('Game over. You\\'ve answered all 8 questions.');\n              setPromptIsHTML(false);\n              // Score is already updated in the hook, but we need to account for the current answer\n              const finalScore = feedbackResult.isCorrect ? game.score + 1 : game.score;\n              setFeedback(`You made ${finalScore} out of ${game.TOTAL_QUESTIONS} correct predictions.`);\n              setFeedbackClass('');\n            }\n            \n            setTimeout(() => {\n              if (game.questionIndex < game.TOTAL_QUESTIONS) {\n                setFeedback('');\n                setFeedbackClass('');\n              }\n            }, 3000);\n          }, 1800);\n        }\n      },\n      gridToDraw\n    );\n  }, [animating, mode, game, animatePath, gridToDraw, mazeType, formatQuestionPrompt]);\n\n  const handleCanvasClick = useCallback((r, c) => {\n    if (mode !== 'inference' || animating) return;\n    \n    // If showing hidden model, switch back to user's model when they edit\n    if (showHiddenModel) {\n      setShowHiddenModel(false);\n    }\n    \n    let val = game.modelGrid[r][c];\n    if (mazeType === 'walls') {\n      const seq = ['', '/', '\\\\'];\n      let idx = seq.indexOf(val);\n      if (idx === -1) idx = 0;\n      val = seq[(idx + 1) % seq.length];\n    } else {\n      const seq = ['', 'U', 'R', 'D', 'L'];\n      let idx = seq.indexOf(val);\n      if (idx === -1) idx = 0;\n      val = seq[(idx + 1) % seq.length];\n    }\n    game.updateModelGrid(r, c, val);\n  }, [mode, animating, game, mazeType, showHiddenModel]);\n\n  const handleTestModel = useCallback(() => {\n    if (mode !== 'inference') return;\n    const result = game.testModel();\n    console.log('handleTestModel result:', result);\n    setFeedback(result.feedback);\n    setFeedbackClass('');\n    // Show \"Show Hidden Model\" button if model didn't match perfectly\n    const shouldShowButton = result.didNotMatch === true;\n    console.log('shouldShowButton:', shouldShowButton, 'result.didNotMatch:', result.didNotMatch);\n    setModelDidNotMatch(shouldShowButton);\n    // Reset show hidden model when testing again\n    setShowHiddenModel(false);\n  }, [mode, game]);\n\n  const handleShowHiddenModel = useCallback(() => {\n    setShowHiddenModel(true);\n  }, []);\n\n  return (\n    <div className={styles.app}>\n      <div className={styles.header}>\n        <img \n          src={(process.env.PUBLIC_URL || '.') + '/MouseInAHole.png'} \n          alt=\"Mouse Mazes Logo\" \n          className={styles.logo}\n        />\n        <h1 className={styles.title}>Mouse Mazes</h1>\n      </div>\n      <GameControls\n        mode={mode}\n        mazeType={mazeType}\n        level={level}\n        onModeChange={handleModeChange}\n        onMazeTypeChange={handleMazeTypeChange}\n        onLevelChange={handleLevelChange}\n        onNewGame={handleNewGame}\n      />\n      <div className={styles.gameArea}>\n        <GameBoard\n          mode={mode}\n          gridToDraw={gridToDraw}\n          animating={animating}\n          onHoleClick={handleHoleClick}\n          onCanvasClick={handleCanvasClick}\n          mouseMarkerRef={mouseMarkerRef}\n          holeRefs={holeRefs}\n          canvasRef={canvasRef}\n        />\n        <SidePanel\n          mode={mode}\n          mazeType={mazeType}\n          prompt={prompt}\n          promptIsHTML={promptIsHTML}\n          feedback={feedback}\n          feedbackClass={feedbackClass}\n          score={game.score}\n          questionIndex={game.questionIndex}\n          totalQuestions={game.TOTAL_QUESTIONS}\n          onTestModel={handleTestModel}\n          onNoExitClick={handleNoExitClick}\n          logEntries={logEntries}\n          questionHistory={questionHistory}\n          onShowHiddenModel={handleShowHiddenModel}\n          showHiddenModelButton={(() => {\n            const shouldShow = modelDidNotMatch && !showHiddenModel;\n            console.log('SidePanel prop calculation - modelDidNotMatch:', modelDidNotMatch, 'showHiddenModel:', showHiddenModel, 'shouldShow:', shouldShow);\n            return shouldShow;\n          })()}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}