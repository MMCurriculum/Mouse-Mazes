{"ast":null,"code":"import{useState,useCallback,useRef}from'react';import{makeMaze,emptyGrid,computeMappingForGrid,simulateHoleWithGrid,randInt}from'../utils/mazeUtils';const TOTAL_QUESTIONS=8;export function useMazeGame(mazeType,level,mode){const[realGrid,setRealGrid]=useState(()=>emptyGrid());const[modelGrid,setModelGrid]=useState(()=>emptyGrid());const[mapping,setMapping]=useState({});const[gameActive,setGameActive]=useState(false);const[questionIndex,setQuestionIndex]=useState(0);const[score,setScore]=useState(0);const[awaitingAnswer,setAwaitingAnswer]=useState(false);const[currentQuestion,setCurrentQuestion]=useState(null);const[inferenceProbeCount,setInferenceProbeCount]=useState(0);// Refs for tracking used questions\nconst usedForwardStarts=useRef(new Set());const usedReverseWallsEnds=useRef(new Set());const usedReverseArrowsEnds=useRef(new Set());const introColorToggle=useRef(false);const chooseForwardStart=useCallback(()=>{const candidates=[];for(let h=1;h<=16;h++){if(!usedForwardStarts.current.has(h))candidates.push(h);}if(candidates.length===0)return 1;const startHole=candidates[randInt(0,candidates.length-1)];usedForwardStarts.current.add(startHole);return startHole;},[]);const chooseReverseWalls=useCallback(mapping=>{const pairs=[];for(let h=1;h<=16;h++){const info=mapping[h];if(!info.trapped&&info.exitHole!==null&&!usedReverseWallsEnds.current.has(info.exitHole)){pairs.push({startHole:h,endHole:info.exitHole});}}if(pairs.length===0)return null;const choice=pairs[randInt(0,pairs.length-1)];usedReverseWallsEnds.current.add(choice.endHole);return choice;},[]);const chooseReverseArrows=useCallback(mapping=>{const endMap={};for(let h=1;h<=16;h++){const info=mapping[h];if(!info.trapped&&info.exitHole!==null&&!usedReverseArrowsEnds.current.has(info.exitHole)){if(!endMap[info.exitHole])endMap[info.exitHole]=[];endMap[info.exitHole].push(h);}}const ends=Object.keys(endMap);if(ends.length===0)return null;const endHole=parseInt(ends[randInt(0,ends.length-1)]);usedReverseArrowsEnds.current.add(endHole);const starts=endMap[endHole];return{endHole,starts};},[]);const startIntroGame=useCallback(()=>{setGameActive(true);setQuestionIndex(0);setScore(0);usedForwardStarts.current=new Set();usedReverseWallsEnds.current=new Set();usedReverseArrowsEnds.current=new Set();const{realGrid:newRealGrid,mapping:newMapping}=makeMaze(mazeType,level);setRealGrid(newRealGrid);setMapping(newMapping);setModelGrid(emptyGrid());setQuestionIndex(1);setAwaitingAnswer(true);// Return question data for first question\nlet useReverse=false;if(level===\"intermediate\")useReverse=Math.random()<0.4;else if(level===\"expert\")useReverse=Math.random()<0.6;if(!useReverse){const startHole=chooseForwardStart();const info=newMapping[startHole];const question={mode:\"forward\",startHole,exitHole:info.exitHole,trapped:info.trapped};setCurrentQuestion(question);return{question,questionIndex:1};}else{if(mazeType===\"walls\"){const choice=chooseReverseWalls(newMapping);if(!choice){// Retry with forward\nconst startHole=chooseForwardStart();const info=newMapping[startHole];const question={mode:\"forward\",startHole,exitHole:info.exitHole,trapped:info.trapped};setCurrentQuestion(question);return{question,questionIndex:1};}const{endHole,startHole}=choice;const question={mode:\"reverseWalls\",endHole,startHole};setCurrentQuestion(question);return{question,questionIndex:1};}else{const choice=chooseReverseArrows(newMapping);if(!choice){// Retry with forward\nconst startHole=chooseForwardStart();const info=newMapping[startHole];const question={mode:\"forward\",startHole,exitHole:info.exitHole,trapped:info.trapped};setCurrentQuestion(question);return{question,questionIndex:1};}const{endHole,starts}=choice;const question={mode:\"reverseArrows\",endHole,starts};setCurrentQuestion(question);return{question,questionIndex:1};}}},[mazeType,level,chooseForwardStart,chooseReverseWalls,chooseReverseArrows]);const nextQuestion=useCallback(currentMapping=>{setQuestionIndex(prev=>{const newIndex=prev+1;if(newIndex>TOTAL_QUESTIONS){setGameActive(false);setAwaitingAnswer(false);return newIndex;}let useReverse=false;if(level===\"intermediate\")useReverse=Math.random()<0.4;else if(level===\"expert\")useReverse=Math.random()<0.6;if(!useReverse){const startHole=chooseForwardStart();const info=currentMapping[startHole];const question={mode:\"forward\",startHole,exitHole:info.exitHole,trapped:info.trapped};setCurrentQuestion(question);setAwaitingAnswer(true);return newIndex;}else{if(mazeType===\"walls\"){const choice=chooseReverseWalls(currentMapping);if(!choice){// Retry with forward\nconst startHole=chooseForwardStart();const info=currentMapping[startHole];const question={mode:\"forward\",startHole,exitHole:info.exitHole,trapped:info.trapped};setCurrentQuestion(question);setAwaitingAnswer(true);return newIndex;}const{endHole,startHole}=choice;const question={mode:\"reverseWalls\",endHole,startHole};setCurrentQuestion(question);setAwaitingAnswer(true);return newIndex;}else{const choice=chooseReverseArrows(currentMapping);if(!choice){// Retry with forward\nconst startHole=chooseForwardStart();const info=currentMapping[startHole];const question={mode:\"forward\",startHole,exitHole:info.exitHole,trapped:info.trapped};setCurrentQuestion(question);setAwaitingAnswer(true);return newIndex;}const{endHole,starts}=choice;const question={mode:\"reverseArrows\",endHole,starts};setCurrentQuestion(question);setAwaitingAnswer(true);return newIndex;}}});},[level,mazeType,chooseForwardStart,chooseReverseWalls,chooseReverseArrows]);const handleIntroAnswer=useCallback((holeNum,isNoExit)=>{if(!gameActive||!awaitingAnswer){return null;}setAwaitingAnswer(false);const q=currentQuestion;if(!q)return null;let isCorrect=false;let animStartHole;if(q.mode===\"forward\"){animStartHole=q.startHole;if(q.trapped&&mazeType===\"arrows\"){isCorrect=isNoExit;}else{isCorrect=!isNoExit&&holeNum===q.exitHole;}}else if(q.mode===\"reverseWalls\"){animStartHole=q.startHole;isCorrect=!isNoExit&&holeNum===q.startHole;}else{if(isNoExit){animStartHole=q.starts[0];isCorrect=false;}else{animStartHole=holeNum;isCorrect=q.starts.includes(holeNum);}}const info=mapping[animStartHole]||simulateHoleWithGrid(animStartHole,realGrid);const after=()=>{if(isCorrect){setScore(prev=>prev+1);}// Return feedback data\nlet feedback=\"\";let feedbackClass=\"\";if(isCorrect){if(info.trapped&&q.mode===\"forward\"&&mazeType===\"arrows\"){feedback=\"Nice work — in this maze that mouse never comes out.\";}else if(q.mode===\"reverseArrows\"){const list=q.starts.join(\", \");feedback=\"Nice work \\u2014 that matches the maze. (Possible starting hole(s): \".concat(list,\")\");}else{feedback=\"Nice work — that matches the maze.\";}feedbackClass=\"correct\";}else{if(info.trapped){if(q.mode===\"forward\"&&mazeType===\"arrows\"&&!isNoExit){feedback=\"That mouse is stuck in the house forever — the correct choice was that it doesn't come out.\";}else{feedback=\"That mouse is stuck in the house forever!\";}feedbackClass=\"\";}else{if(q.mode===\"forward\"){feedback=\"Oops \\u2014 it actually came out at hole \".concat(q.exitHole,\".\");}else if(q.mode===\"reverseWalls\"){feedback=\"Oops \\u2014 it actually started at hole \".concat(q.startHole,\".\");}else{const list=q.starts.join(\", \");feedback=\"Oops \\u2014 Possible starting hole(s): \".concat(list,\".\");}feedbackClass=\"incorrect\";}}return{feedback,feedbackClass,isCorrect};};return{info,animStartHole,after};},[gameActive,awaitingAnswer,currentQuestion,mapping,realGrid,mazeType]);const handleInferenceProbe=useCallback(holeNum=>{setInferenceProbeCount(prev=>prev+1);const info=mapping[holeNum]||simulateHoleWithGrid(holeNum,realGrid);return{info,probeCount:inferenceProbeCount+1};},[mapping,realGrid,inferenceProbeCount]);const testModel=useCallback(()=>{console.log('=== TESTING MODEL ===');console.log('Real Grid State:',realGrid);console.log('Real Grid (formatted):');console.log(realGrid.map((row,r)=>row.map((cell,c)=>\"\".concat(r,\",\").concat(c,\":\").concat(cell||'empty')).join(' | ')).join('\\n'));console.log('Model Grid State:',modelGrid);console.log('Model Grid (formatted):');console.log(modelGrid.map((row,r)=>row.map((cell,c)=>\"\".concat(r,\",\").concat(c,\":\").concat(cell||'empty')).join(' | ')).join('\\n'));const modelMap=computeMappingForGrid(modelGrid);console.log('Model Mapping (computed from grid):',modelMap);const realMap=mapping;console.log('Real Mapping (actual maze):',realMap);let matches=0;for(let h=1;h<=16;h++){const a=realMap[h];const b=modelMap[h];let same=false;if(a.trapped&&b.trapped)same=true;else if(!a.trapped&&!b.trapped&&a.exitHole===b.exitHole)same=true;if(same)matches++;}let sameLayout=true;for(let r=0;r<4;r++){for(let c=0;c<4;c++){if(realGrid[r][c]!==modelGrid[r][c]){sameLayout=false;break;}}if(!sameLayout)break;}const probeMsg=\" You have sent \".concat(inferenceProbeCount,\" mice into the maze.\");// Check if model has been meaningfully built (count non-empty cells)\nlet modelCellCount=0;for(let r=0;r<4;r++){for(let c=0;c<4;c++){if(modelGrid[r][c]){modelCellCount++;}}}// Only show button if model has at least 4 cells filled (meaningful attempt)\nconst modelIsSubstantial=modelCellCount>=4;let feedback=\"\";let didNotMatch=false;if(matches===16){if(sameLayout){feedback=\"Your model is right! All 16 mice behave correctly and your layout matches the hidden one.\"+probeMsg;didNotMatch=false;}else{feedback=\"Your model works. All 16 mice behave correctly, though your layout is different from mine. More than one right answer is possible.\"+probeMsg;// Only show button if model is successful (all 16 work) but layout is different, and model is substantially built\ndidNotMatch=modelIsSubstantial;}}else{feedback=\"\".concat(matches,\" of your mice arrive in the right place for that model.\")+probeMsg;// Don't show button if model doesn't work (matches < 16)\ndidNotMatch=false;}console.log('Test Model Result:',{matches,sameLayout,didNotMatch,feedback,modelIsSubstantial,modelCellCount});return{feedback,didNotMatch};},[modelGrid,mapping,realGrid,inferenceProbeCount]);const resetModelGrid=useCallback(()=>{setModelGrid(emptyGrid());},[]);const startInferenceGame=useCallback(()=>{setGameActive(false);setAwaitingAnswer(false);const{realGrid:newRealGrid,mapping:newMapping}=makeMaze(mazeType,level);setRealGrid(newRealGrid);setMapping(newMapping);setModelGrid(emptyGrid());setInferenceProbeCount(0);console.log('=== NEW INFERENCE GAME STARTED ===');console.log('Real Grid State:',newRealGrid);console.log('Real Grid (formatted):');console.log(newRealGrid.map((row,r)=>row.map((cell,c)=>\"\".concat(r,\",\").concat(c,\":\").concat(cell||'empty')).join(' | ')).join('\\n'));console.log('Real Mapping (actual maze):',newMapping);return{realGrid:newRealGrid,mapping:newMapping};},[mazeType,level]);const updateModelGrid=useCallback((r,c,value)=>{setModelGrid(prev=>{const newGrid=prev.map(row=>[...row]);newGrid[r][c]=value;console.log(\"Model Grid Updated: [\".concat(r,\"][\").concat(c,\"] = \\\"\").concat(value,\"\\\"\"));console.log('Current Model Grid:',newGrid);return newGrid;});},[]);const toggleIntroColor=useCallback(()=>{introColorToggle.current=!introColorToggle.current;return introColorToggle.current;},[]);return{realGrid,modelGrid,mapping,gameActive,questionIndex,score,awaitingAnswer,currentQuestion,inferenceProbeCount,TOTAL_QUESTIONS,startIntroGame,handleIntroAnswer,nextQuestion,handleInferenceProbe,testModel,resetModelGrid,startInferenceGame,updateModelGrid,toggleIntroColor};}","map":{"version":3,"names":["useState","useCallback","useRef","makeMaze","emptyGrid","computeMappingForGrid","simulateHoleWithGrid","randInt","TOTAL_QUESTIONS","useMazeGame","mazeType","level","mode","realGrid","setRealGrid","modelGrid","setModelGrid","mapping","setMapping","gameActive","setGameActive","questionIndex","setQuestionIndex","score","setScore","awaitingAnswer","setAwaitingAnswer","currentQuestion","setCurrentQuestion","inferenceProbeCount","setInferenceProbeCount","usedForwardStarts","Set","usedReverseWallsEnds","usedReverseArrowsEnds","introColorToggle","chooseForwardStart","candidates","h","current","has","push","length","startHole","add","chooseReverseWalls","pairs","info","trapped","exitHole","endHole","choice","chooseReverseArrows","endMap","ends","Object","keys","parseInt","starts","startIntroGame","newRealGrid","newMapping","useReverse","Math","random","question","nextQuestion","currentMapping","prev","newIndex","handleIntroAnswer","holeNum","isNoExit","q","isCorrect","animStartHole","includes","after","feedback","feedbackClass","list","join","concat","handleInferenceProbe","probeCount","testModel","console","log","map","row","r","cell","c","modelMap","realMap","matches","a","b","same","sameLayout","probeMsg","modelCellCount","modelIsSubstantial","didNotMatch","resetModelGrid","startInferenceGame","updateModelGrid","value","newGrid","toggleIntroColor"],"sources":["/Users/joshuaabrams/Library/CloudStorage/Dropbox/Professional Development Activities & Workshops/*Making Math Website/VariedContent/Geometry/LogicAndReasoning/MouseMazes/mouse-mazes-react/src/hooks/useMazeGame.js"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\nimport { makeMaze, emptyGrid, computeMappingForGrid, simulateHoleWithGrid, randInt } from '../utils/mazeUtils';\n\nconst TOTAL_QUESTIONS = 8;\n\nexport function useMazeGame(mazeType, level, mode) {\n  const [realGrid, setRealGrid] = useState(() => emptyGrid());\n  const [modelGrid, setModelGrid] = useState(() => emptyGrid());\n  const [mapping, setMapping] = useState({});\n  const [gameActive, setGameActive] = useState(false);\n  const [questionIndex, setQuestionIndex] = useState(0);\n  const [score, setScore] = useState(0);\n  const [awaitingAnswer, setAwaitingAnswer] = useState(false);\n  const [currentQuestion, setCurrentQuestion] = useState(null);\n  const [inferenceProbeCount, setInferenceProbeCount] = useState(0);\n  \n  // Refs for tracking used questions\n  const usedForwardStarts = useRef(new Set());\n  const usedReverseWallsEnds = useRef(new Set());\n  const usedReverseArrowsEnds = useRef(new Set());\n  const introColorToggle = useRef(false);\n\n  const chooseForwardStart = useCallback(() => {\n    const candidates = [];\n    for (let h = 1; h <= 16; h++) {\n      if (!usedForwardStarts.current.has(h)) candidates.push(h);\n    }\n    if (candidates.length === 0) return 1;\n    const startHole = candidates[randInt(0, candidates.length - 1)];\n    usedForwardStarts.current.add(startHole);\n    return startHole;\n  }, []);\n\n  const chooseReverseWalls = useCallback((mapping) => {\n    const pairs = [];\n    for (let h = 1; h <= 16; h++) {\n      const info = mapping[h];\n      if (!info.trapped && info.exitHole !== null &&\n          !usedReverseWallsEnds.current.has(info.exitHole)) {\n        pairs.push({startHole: h, endHole: info.exitHole});\n      }\n    }\n    if (pairs.length === 0) return null;\n    const choice = pairs[randInt(0, pairs.length - 1)];\n    usedReverseWallsEnds.current.add(choice.endHole);\n    return choice;\n  }, []);\n\n  const chooseReverseArrows = useCallback((mapping) => {\n    const endMap = {};\n    for (let h = 1; h <= 16; h++) {\n      const info = mapping[h];\n      if (!info.trapped && info.exitHole !== null &&\n          !usedReverseArrowsEnds.current.has(info.exitHole)) {\n        if (!endMap[info.exitHole]) endMap[info.exitHole] = [];\n        endMap[info.exitHole].push(h);\n      }\n    }\n    const ends = Object.keys(endMap);\n    if (ends.length === 0) return null;\n    const endHole = parseInt(ends[randInt(0, ends.length - 1)]);\n    usedReverseArrowsEnds.current.add(endHole);\n    const starts = endMap[endHole];\n    return {endHole, starts};\n  }, []);\n\n  const startIntroGame = useCallback(() => {\n    setGameActive(true);\n    setQuestionIndex(0);\n    setScore(0);\n    usedForwardStarts.current = new Set();\n    usedReverseWallsEnds.current = new Set();\n    usedReverseArrowsEnds.current = new Set();\n    \n    const { realGrid: newRealGrid, mapping: newMapping } = makeMaze(mazeType, level);\n    setRealGrid(newRealGrid);\n    setMapping(newMapping);\n    setModelGrid(emptyGrid());\n    setQuestionIndex(1);\n    setAwaitingAnswer(true);\n    \n    // Return question data for first question\n    let useReverse = false;\n    if (level === \"intermediate\") useReverse = Math.random() < 0.4;\n    else if (level === \"expert\") useReverse = Math.random() < 0.6;\n\n    if (!useReverse) {\n      const startHole = chooseForwardStart();\n      const info = newMapping[startHole];\n      const question = {\n        mode: \"forward\",\n        startHole,\n        exitHole: info.exitHole,\n        trapped: info.trapped\n      };\n      setCurrentQuestion(question);\n      return { question, questionIndex: 1 };\n    } else {\n      if (mazeType === \"walls\") {\n        const choice = chooseReverseWalls(newMapping);\n        if (!choice) {\n          // Retry with forward\n          const startHole = chooseForwardStart();\n          const info = newMapping[startHole];\n          const question = {\n            mode: \"forward\",\n            startHole,\n            exitHole: info.exitHole,\n            trapped: info.trapped\n          };\n          setCurrentQuestion(question);\n          return { question, questionIndex: 1 };\n        }\n        const {endHole, startHole} = choice;\n        const question = {\n          mode:\"reverseWalls\",\n          endHole,\n          startHole\n        };\n        setCurrentQuestion(question);\n        return { question, questionIndex: 1 };\n      } else {\n        const choice = chooseReverseArrows(newMapping);\n        if (!choice) {\n          // Retry with forward\n          const startHole = chooseForwardStart();\n          const info = newMapping[startHole];\n          const question = {\n            mode: \"forward\",\n            startHole,\n            exitHole: info.exitHole,\n            trapped: info.trapped\n          };\n          setCurrentQuestion(question);\n          return { question, questionIndex: 1 };\n        }\n        const {endHole, starts} = choice;\n        const question = {\n          mode:\"reverseArrows\",\n          endHole,\n          starts\n        };\n        setCurrentQuestion(question);\n        return { question, questionIndex: 1 };\n      }\n    }\n  }, [mazeType, level, chooseForwardStart, chooseReverseWalls, chooseReverseArrows]);\n\n  const nextQuestion = useCallback((currentMapping) => {\n    setQuestionIndex(prev => {\n      const newIndex = prev + 1;\n      if (newIndex > TOTAL_QUESTIONS) {\n        setGameActive(false);\n        setAwaitingAnswer(false);\n        return newIndex;\n      }\n\n      let useReverse = false;\n      if (level === \"intermediate\") useReverse = Math.random() < 0.4;\n      else if (level === \"expert\") useReverse = Math.random() < 0.6;\n\n      if (!useReverse) {\n        const startHole = chooseForwardStart();\n        const info = currentMapping[startHole];\n        const question = {\n          mode: \"forward\",\n          startHole,\n          exitHole: info.exitHole,\n          trapped: info.trapped\n        };\n        setCurrentQuestion(question);\n        setAwaitingAnswer(true);\n        return newIndex;\n      } else {\n        if (mazeType === \"walls\") {\n          const choice = chooseReverseWalls(currentMapping);\n          if (!choice) {\n            // Retry with forward\n            const startHole = chooseForwardStart();\n            const info = currentMapping[startHole];\n            const question = {\n              mode: \"forward\",\n              startHole,\n              exitHole: info.exitHole,\n              trapped: info.trapped\n            };\n            setCurrentQuestion(question);\n            setAwaitingAnswer(true);\n            return newIndex;\n          }\n          const {endHole, startHole} = choice;\n          const question = {\n            mode:\"reverseWalls\",\n            endHole,\n            startHole\n          };\n          setCurrentQuestion(question);\n          setAwaitingAnswer(true);\n          return newIndex;\n        } else {\n          const choice = chooseReverseArrows(currentMapping);\n          if (!choice) {\n            // Retry with forward\n            const startHole = chooseForwardStart();\n            const info = currentMapping[startHole];\n            const question = {\n              mode: \"forward\",\n              startHole,\n              exitHole: info.exitHole,\n              trapped: info.trapped\n            };\n            setCurrentQuestion(question);\n            setAwaitingAnswer(true);\n            return newIndex;\n          }\n          const {endHole, starts} = choice;\n          const question = {\n            mode:\"reverseArrows\",\n            endHole,\n            starts\n          };\n          setCurrentQuestion(question);\n          setAwaitingAnswer(true);\n          return newIndex;\n        }\n      }\n    });\n  }, [level, mazeType, chooseForwardStart, chooseReverseWalls, chooseReverseArrows]);\n\n  const handleIntroAnswer = useCallback((holeNum, isNoExit) => {\n    if (!gameActive || !awaitingAnswer) {\n      return null;\n    }\n\n    setAwaitingAnswer(false);\n    const q = currentQuestion;\n    if (!q) return null;\n    \n    let isCorrect = false;\n    let animStartHole;\n\n    if (q.mode === \"forward\") {\n      animStartHole = q.startHole;\n      if (q.trapped && mazeType === \"arrows\") {\n        isCorrect = isNoExit;\n      } else {\n        isCorrect = (!isNoExit && holeNum === q.exitHole);\n      }\n    } else if (q.mode === \"reverseWalls\") {\n      animStartHole = q.startHole;\n      isCorrect = (!isNoExit && holeNum === q.startHole);\n    } else {\n      if (isNoExit) {\n        animStartHole = q.starts[0];\n        isCorrect = false;\n      } else {\n        animStartHole = holeNum;\n        isCorrect = q.starts.includes(holeNum);\n      }\n    }\n\n    const info = mapping[animStartHole] || simulateHoleWithGrid(animStartHole, realGrid);\n\n    const after = () => {\n      if (isCorrect) {\n        setScore(prev => prev + 1);\n      }\n      \n      // Return feedback data\n      let feedback = \"\";\n      let feedbackClass = \"\";\n      \n      if (isCorrect) {\n        if (info.trapped && q.mode === \"forward\" && mazeType === \"arrows\") {\n          feedback = \"Nice work — in this maze that mouse never comes out.\";\n        } else if (q.mode === \"reverseArrows\") {\n          const list = q.starts.join(\", \");\n          feedback = `Nice work — that matches the maze. (Possible starting hole(s): ${list})`;\n        } else {\n          feedback = \"Nice work — that matches the maze.\";\n        }\n        feedbackClass = \"correct\";\n      } else {\n        if (info.trapped) {\n          if (q.mode === \"forward\" && mazeType === \"arrows\" && !isNoExit) {\n            feedback = \"That mouse is stuck in the house forever — the correct choice was that it doesn't come out.\";\n          } else {\n            feedback = \"That mouse is stuck in the house forever!\";\n          }\n          feedbackClass = \"\";\n        } else {\n          if (q.mode === \"forward\") {\n            feedback = `Oops — it actually came out at hole ${q.exitHole}.`;\n          } else if (q.mode === \"reverseWalls\") {\n            feedback = `Oops — it actually started at hole ${q.startHole}.`;\n          } else {\n            const list = q.starts.join(\", \");\n            feedback = `Oops — Possible starting hole(s): ${list}.`;\n          }\n          feedbackClass = \"incorrect\";\n        }\n      }\n\n      return { feedback, feedbackClass, isCorrect };\n    };\n\n    return { info, animStartHole, after };\n  }, [gameActive, awaitingAnswer, currentQuestion, mapping, realGrid, mazeType]);\n\n  const handleInferenceProbe = useCallback((holeNum) => {\n    setInferenceProbeCount(prev => prev + 1);\n    const info = mapping[holeNum] || simulateHoleWithGrid(holeNum, realGrid);\n    return { info, probeCount: inferenceProbeCount + 1 };\n  }, [mapping, realGrid, inferenceProbeCount]);\n\n  const testModel = useCallback(() => {\n    console.log('=== TESTING MODEL ===');\n    console.log('Real Grid State:', realGrid);\n    console.log('Real Grid (formatted):');\n    console.log(realGrid.map((row, r) => \n      row.map((cell, c) => `${r},${c}:${cell || 'empty'}`).join(' | ')\n    ).join('\\n'));\n    \n    console.log('Model Grid State:', modelGrid);\n    console.log('Model Grid (formatted):');\n    console.log(modelGrid.map((row, r) => \n      row.map((cell, c) => `${r},${c}:${cell || 'empty'}`).join(' | ')\n    ).join('\\n'));\n    \n    const modelMap = computeMappingForGrid(modelGrid);\n    console.log('Model Mapping (computed from grid):', modelMap);\n    \n    const realMap = mapping;\n    console.log('Real Mapping (actual maze):', realMap);\n\n    let matches = 0;\n    for (let h = 1; h <= 16; h++) {\n      const a = realMap[h];\n      const b = modelMap[h];\n      let same = false;\n      if (a.trapped && b.trapped) same = true;\n      else if (!a.trapped && !b.trapped && a.exitHole === b.exitHole) same = true;\n      if (same) matches++;\n    }\n\n    let sameLayout = true;\n    for (let r = 0; r < 4; r++) {\n      for (let c = 0; c < 4; c++) {\n        if (realGrid[r][c] !== modelGrid[r][c]) {\n          sameLayout = false;\n          break;\n        }\n      }\n      if (!sameLayout) break;\n    }\n\n    const probeMsg = ` You have sent ${inferenceProbeCount} mice into the maze.`;\n\n    // Check if model has been meaningfully built (count non-empty cells)\n    let modelCellCount = 0;\n    for (let r = 0; r < 4; r++) {\n      for (let c = 0; c < 4; c++) {\n        if (modelGrid[r][c]) {\n          modelCellCount++;\n        }\n      }\n    }\n    // Only show button if model has at least 4 cells filled (meaningful attempt)\n    const modelIsSubstantial = modelCellCount >= 4;\n\n    let feedback = \"\";\n    let didNotMatch = false;\n    if (matches === 16) {\n      if (sameLayout) {\n        feedback = \"Your model is right! All 16 mice behave correctly and your layout matches the hidden one.\" + probeMsg;\n        didNotMatch = false;\n      } else {\n        feedback = \"Your model works. All 16 mice behave correctly, though your layout is different from mine. More than one right answer is possible.\" + probeMsg;\n        // Only show button if model is successful (all 16 work) but layout is different, and model is substantially built\n        didNotMatch = modelIsSubstantial;\n      }\n    } else {\n      feedback = `${matches} of your mice arrive in the right place for that model.` + probeMsg;\n      // Don't show button if model doesn't work (matches < 16)\n      didNotMatch = false;\n    }\n\n    console.log('Test Model Result:', { matches, sameLayout, didNotMatch, feedback, modelIsSubstantial, modelCellCount });\n    return { feedback, didNotMatch };\n  }, [modelGrid, mapping, realGrid, inferenceProbeCount]);\n\n  const resetModelGrid = useCallback(() => {\n    setModelGrid(emptyGrid());\n  }, []);\n\n  const startInferenceGame = useCallback(() => {\n    setGameActive(false);\n    setAwaitingAnswer(false);\n    const { realGrid: newRealGrid, mapping: newMapping } = makeMaze(mazeType, level);\n    setRealGrid(newRealGrid);\n    setMapping(newMapping);\n    setModelGrid(emptyGrid());\n    setInferenceProbeCount(0);\n    \n    console.log('=== NEW INFERENCE GAME STARTED ===');\n    console.log('Real Grid State:', newRealGrid);\n    console.log('Real Grid (formatted):');\n    console.log(newRealGrid.map((row, r) => \n      row.map((cell, c) => `${r},${c}:${cell || 'empty'}`).join(' | ')\n    ).join('\\n'));\n    console.log('Real Mapping (actual maze):', newMapping);\n    \n    return { realGrid: newRealGrid, mapping: newMapping };\n  }, [mazeType, level]);\n\n  const updateModelGrid = useCallback((r, c, value) => {\n    setModelGrid(prev => {\n      const newGrid = prev.map(row => [...row]);\n      newGrid[r][c] = value;\n      console.log(`Model Grid Updated: [${r}][${c}] = \"${value}\"`);\n      console.log('Current Model Grid:', newGrid);\n      return newGrid;\n    });\n  }, []);\n\n  const toggleIntroColor = useCallback(() => {\n    introColorToggle.current = !introColorToggle.current;\n    return introColorToggle.current;\n  }, []);\n\n  return {\n    realGrid,\n    modelGrid,\n    mapping,\n    gameActive,\n    questionIndex,\n    score,\n    awaitingAnswer,\n    currentQuestion,\n    inferenceProbeCount,\n    TOTAL_QUESTIONS,\n    startIntroGame,\n    handleIntroAnswer,\n    nextQuestion,\n    handleInferenceProbe,\n    testModel,\n    resetModelGrid,\n    startInferenceGame,\n    updateModelGrid,\n    toggleIntroColor\n  };\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}