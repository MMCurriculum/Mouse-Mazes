{"ast":null,"code":"import{useState,useRef,useCallback}from'react';import{holeWallCoords}from'../utils/mazeUtils';import{drawMaze as drawMazeUtil}from'../utils/drawingUtils';const CANVAS_SIZE=600;const SIZE=4;const CELL=CANVAS_SIZE/SIZE;// Cache for the mouse image - preload it\nlet mouseImageCache=null;// Preload the mouse image\nconst mouseImage=new Image();mouseImage.onload=()=>{mouseImageCache=mouseImage;};mouseImage.onerror=()=>{console.warn('Failed to load mouse image: /movingmouse.png');};mouseImage.src='/movingmouse.png';function drawMouseOnCanvas(ctx,x,y,direction){if(!mouseImageCache){// Image not loaded yet, skip drawing\nreturn;}ctx.save();// Move to center point\nctx.translate(x,y);// Apply transformations based on direction\n// Image faces right by default\nif(direction==='right'){// No transformation needed (already faces right)\n}else if(direction==='down'){// Rotate 90 degrees clockwise\nctx.rotate(Math.PI/2);}else if(direction==='left'){// Flip horizontally to face left\nctx.scale(-1,1);}else if(direction==='up'){// Rotate 90 degrees counterclockwise\nctx.rotate(-Math.PI/2);}// Add shadow effect\nctx.shadowColor=\"rgba(0, 0, 0, 0.4)\";ctx.shadowBlur=3;ctx.shadowOffsetX=0;ctx.shadowOffsetY=3;// Draw image centered, scaled to 36px (50% of 72px)\nconst imgSize=36;ctx.drawImage(mouseImageCache,-imgSize/2,-imgSize/2,imgSize,imgSize);ctx.restore();}function getDirection(p1,p2){const dx=p2.x-p1.x;const dy=p2.y-p1.y;// Determine primary direction\nif(Math.abs(dx)>Math.abs(dy)){return dx>0?'right':'left';}else{return dy>0?'down':'up';}}export function useAnimation(ctxRef,canvasRef,drawMaze,mouseMarkerRef){const[animating,setAnimating]=useState(false);const animationFrameRef=useRef(null);const animatePath=useCallback((path,exitHole,trapped,startHole,after,gridToDraw)=>{if(!canvasRef.current)return;// Ensure context is set\nif(!ctxRef.current&&canvasRef.current){ctxRef.current=canvasRef.current.getContext('2d');}if(!ctxRef.current)return;setAnimating(true);const points=[];points.push(holeWallCoords(startHole,CELL,CANVAS_SIZE,CANVAS_SIZE));for(const p of path){points.push({x:p.c*CELL+CELL/2,y:p.r*CELL+CELL/2});}if(!trapped&&exitHole!==null&&exitHole!==undefined){points.push(holeWallCoords(exitHole,CELL,CANVAS_SIZE,CANVAS_SIZE));}if(points.length<2){setAnimating(false);if(after)after();return;}let segIndex=0;let frame=0;const framesPerSeg=19;// 25% slower: 15 * 1.25 = 18.75, rounded to 19\nconst step=()=>{if(!ctxRef.current||!canvasRef.current)return;drawMazeUtil(ctxRef.current,canvasRef.current,gridToDraw,CELL);ctxRef.current.strokeStyle=\"rgba(255,200,80,0.6)\";ctxRef.current.lineWidth=6;ctxRef.current.lineCap=\"round\";ctxRef.current.beginPath();let started=false;for(let i=0;i<segIndex;i++){const p1=points[i];const p2=points[i+1];if(!started){ctxRef.current.moveTo(p1.x,p1.y);started=true;}ctxRef.current.lineTo(p2.x,p2.y);}const p1=points[segIndex];const p2=points[segIndex+1];const t=frame/framesPerSeg;const x=p1.x+(p2.x-p1.x)*t;const y=p1.y+(p2.y-p1.y)*t;if(!started){ctxRef.current.moveTo(p1.x,p1.y);started=true;}ctxRef.current.lineTo(x,y);ctxRef.current.stroke();ctxRef.current.lineWidth=1;// Determine direction and draw mouse facing that direction\nconst direction=getDirection(p1,p2);drawMouseOnCanvas(ctxRef.current,x,y,direction);frame++;if(frame>framesPerSeg){frame=0;segIndex++;if(segIndex>=points.length-1){setAnimating(false);if(after)after();return;}}animationFrameRef.current=requestAnimationFrame(step);};animationFrameRef.current=requestAnimationFrame(step);},[ctxRef,canvasRef]);const animateDomSegment=useCallback((p1,p2,callback)=>{if(!mouseMarkerRef.current)return;setAnimating(true);const frames=56;// 25% slower: 45 * 1.25 = 56.25, rounded to 56\nlet frame=0;mouseMarkerRef.current.style.display=\"block\";// Determine direction for this segment\nconst direction=getDirection(p1,p2);let transform='';// Apply transformations based on direction (image faces right by default)\nif(direction==='right'){transform='';// No transformation needed\n}else if(direction==='down'){transform='rotate(90deg)';// Rotate 90 degrees clockwise\n}else if(direction==='left'){transform='scaleX(-1)';// Flip horizontally\n}else if(direction==='up'){transform='rotate(-90deg)';// Rotate 90 degrees counterclockwise\n}mouseMarkerRef.current.style.transform=transform;const step=()=>{if(!mouseMarkerRef.current)return;const t=frame/frames;const x=p1.x+(p2.x-p1.x)*t;const y=p1.y+(p2.y-p1.y)*t;mouseMarkerRef.current.style.left=x-18+\"px\";// 50% of 36px = 18px\nmouseMarkerRef.current.style.top=y-18+\"px\";// 50% of 36px = 18px\nframe++;if(frame>frames){if(callback)callback();return;}animationFrameRef.current=requestAnimationFrame(step);};animationFrameRef.current=requestAnimationFrame(step);},[mouseMarkerRef]);const animateInferenceProbe=useCallback((startHole,info,after,holeRefs)=>{if(!mouseMarkerRef.current)return;const holeStartDiv=holeRefs.find(h=>{var _h$dataset;return h&&parseInt((_h$dataset=h.dataset)===null||_h$dataset===void 0?void 0:_h$dataset.num)===startHole;});if(!holeStartDiv){if(after)after();return;}const startBtn={x:holeStartDiv.offsetLeft+holeStartDiv.offsetWidth/2,y:holeStartDiv.offsetTop+holeStartDiv.offsetHeight/2};const startEdgeCanvas=holeWallCoords(startHole,CELL,CANVAS_SIZE,CANVAS_SIZE);const startEdge={x:startEdgeCanvas.x,y:startEdgeCanvas.y};const doExit=()=>{if(info.trapped||info.exitHole===null||info.exitHole===undefined){if(mouseMarkerRef.current){mouseMarkerRef.current.style.display=\"none\";}setAnimating(false);if(after)after();return;}const holeExitDiv=holeRefs.find(h=>{var _h$dataset2;return h&&parseInt((_h$dataset2=h.dataset)===null||_h$dataset2===void 0?void 0:_h$dataset2.num)===info.exitHole;});if(!holeExitDiv){if(mouseMarkerRef.current){mouseMarkerRef.current.style.display=\"none\";}setAnimating(false);if(after)after();return;}const exitEdgeCanvas=holeWallCoords(info.exitHole,CELL,CANVAS_SIZE,CANVAS_SIZE);const exitEdge={x:exitEdgeCanvas.x,y:exitEdgeCanvas.y};const exitBtn={x:holeExitDiv.offsetLeft+holeExitDiv.offsetWidth/2,y:holeExitDiv.offsetTop+holeExitDiv.offsetHeight/2};animateDomSegment(exitEdge,exitBtn,()=>{if(mouseMarkerRef.current){mouseMarkerRef.current.style.display=\"none\";}setAnimating(false);if(after)after();});};animateDomSegment(startBtn,startEdge,doExit);},[mouseMarkerRef,animateDomSegment]);// Cleanup on unmount\nconst cleanup=useCallback(()=>{if(animationFrameRef.current){cancelAnimationFrame(animationFrameRef.current);}},[]);return{animating,animatePath,animateInferenceProbe,cleanup};}","map":{"version":3,"names":["useState","useRef","useCallback","holeWallCoords","drawMaze","drawMazeUtil","CANVAS_SIZE","SIZE","CELL","mouseImageCache","mouseImage","Image","onload","onerror","console","warn","src","drawMouseOnCanvas","ctx","x","y","direction","save","translate","rotate","Math","PI","scale","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","imgSize","drawImage","restore","getDirection","p1","p2","dx","dy","abs","useAnimation","ctxRef","canvasRef","mouseMarkerRef","animating","setAnimating","animationFrameRef","animatePath","path","exitHole","trapped","startHole","after","gridToDraw","current","getContext","points","push","p","c","r","undefined","length","segIndex","frame","framesPerSeg","step","strokeStyle","lineWidth","lineCap","beginPath","started","i","moveTo","lineTo","t","stroke","requestAnimationFrame","animateDomSegment","callback","frames","style","display","transform","left","top","animateInferenceProbe","info","holeRefs","holeStartDiv","find","h","_h$dataset","parseInt","dataset","num","startBtn","offsetLeft","offsetWidth","offsetTop","offsetHeight","startEdgeCanvas","startEdge","doExit","holeExitDiv","_h$dataset2","exitEdgeCanvas","exitEdge","exitBtn","cleanup","cancelAnimationFrame"],"sources":["/Users/joshuaabrams/Library/CloudStorage/Dropbox/Professional Development Activities & Workshops/*Making Math Website/VariedContent/Geometry/LogicAndReasoning/MouseMazes/mouse-mazes-react/src/hooks/useAnimation.js"],"sourcesContent":["import { useState, useRef, useCallback } from 'react';\nimport { holeWallCoords } from '../utils/mazeUtils';\nimport { drawMaze as drawMazeUtil } from '../utils/drawingUtils';\n\nconst CANVAS_SIZE = 600;\nconst SIZE = 4;\nconst CELL = CANVAS_SIZE / SIZE;\n\n// Cache for the mouse image - preload it\nlet mouseImageCache = null;\n\n// Preload the mouse image\nconst mouseImage = new Image();\nmouseImage.onload = () => {\n  mouseImageCache = mouseImage;\n};\nmouseImage.onerror = () => {\n  console.warn('Failed to load mouse image: /movingmouse.png');\n};\nmouseImage.src = '/movingmouse.png';\n\nfunction drawMouseOnCanvas(ctx, x, y, direction) {\n  if (!mouseImageCache) {\n    // Image not loaded yet, skip drawing\n    return;\n  }\n  \n  ctx.save();\n  \n  // Move to center point\n  ctx.translate(x, y);\n  \n  // Apply transformations based on direction\n  // Image faces right by default\n  if (direction === 'right') {\n    // No transformation needed (already faces right)\n  } else if (direction === 'down') {\n    // Rotate 90 degrees clockwise\n    ctx.rotate(Math.PI / 2);\n  } else if (direction === 'left') {\n    // Flip horizontally to face left\n    ctx.scale(-1, 1);\n  } else if (direction === 'up') {\n    // Rotate 90 degrees counterclockwise\n    ctx.rotate(-Math.PI / 2);\n  }\n  \n  // Add shadow effect\n  ctx.shadowColor = \"rgba(0, 0, 0, 0.4)\";\n  ctx.shadowBlur = 3;\n  ctx.shadowOffsetX = 0;\n  ctx.shadowOffsetY = 3;\n  \n  // Draw image centered, scaled to 36px (50% of 72px)\n  const imgSize = 36;\n  ctx.drawImage(mouseImageCache, -imgSize / 2, -imgSize / 2, imgSize, imgSize);\n  \n  ctx.restore();\n}\n\nfunction getDirection(p1, p2) {\n  const dx = p2.x - p1.x;\n  const dy = p2.y - p1.y;\n  \n  // Determine primary direction\n  if (Math.abs(dx) > Math.abs(dy)) {\n    return dx > 0 ? 'right' : 'left';\n  } else {\n    return dy > 0 ? 'down' : 'up';\n  }\n}\n\nexport function useAnimation(ctxRef, canvasRef, drawMaze, mouseMarkerRef) {\n  const [animating, setAnimating] = useState(false);\n  const animationFrameRef = useRef(null);\n\n  const animatePath = useCallback((path, exitHole, trapped, startHole, after, gridToDraw) => {\n    if (!canvasRef.current) return;\n    \n    // Ensure context is set\n    if (!ctxRef.current && canvasRef.current) {\n      ctxRef.current = canvasRef.current.getContext('2d');\n    }\n    \n    if (!ctxRef.current) return;\n    \n    setAnimating(true);\n    const points = [];\n    points.push(holeWallCoords(startHole, CELL, CANVAS_SIZE, CANVAS_SIZE));\n    for (const p of path) {\n      points.push({ x: p.c * CELL + CELL / 2, y: p.r * CELL + CELL / 2 });\n    }\n    if (!trapped && exitHole !== null && exitHole !== undefined) {\n      points.push(holeWallCoords(exitHole, CELL, CANVAS_SIZE, CANVAS_SIZE));\n    }\n\n    if (points.length < 2) {\n      setAnimating(false);\n      if (after) after();\n      return;\n    }\n\n    let segIndex = 0;\n    let frame = 0;\n    const framesPerSeg = 19; // 25% slower: 15 * 1.25 = 18.75, rounded to 19\n\n    const step = () => {\n      if (!ctxRef.current || !canvasRef.current) return;\n      \n      drawMazeUtil(ctxRef.current, canvasRef.current, gridToDraw, CELL);\n\n      ctxRef.current.strokeStyle = \"rgba(255,200,80,0.6)\";\n      ctxRef.current.lineWidth = 6;\n      ctxRef.current.lineCap = \"round\";\n      ctxRef.current.beginPath();\n      let started = false;\n      for (let i = 0; i < segIndex; i++) {\n        const p1 = points[i];\n        const p2 = points[i+1];\n        if (!started) {\n          ctxRef.current.moveTo(p1.x, p1.y);\n          started = true;\n        }\n        ctxRef.current.lineTo(p2.x, p2.y);\n      }\n      const p1 = points[segIndex];\n      const p2 = points[segIndex+1];\n      const t = frame / framesPerSeg;\n      const x = p1.x + (p2.x - p1.x) * t;\n      const y = p1.y + (p2.y - p1.y) * t;\n      if (!started) {\n        ctxRef.current.moveTo(p1.x, p1.y);\n        started = true;\n      }\n      ctxRef.current.lineTo(x, y);\n      ctxRef.current.stroke();\n      ctxRef.current.lineWidth = 1;\n\n      // Determine direction and draw mouse facing that direction\n      const direction = getDirection(p1, p2);\n      drawMouseOnCanvas(ctxRef.current, x, y, direction);\n\n      frame++;\n      if (frame > framesPerSeg) {\n        frame = 0;\n        segIndex++;\n        if (segIndex >= points.length - 1) {\n          setAnimating(false);\n          if (after) after();\n          return;\n        }\n      }\n      animationFrameRef.current = requestAnimationFrame(step);\n    };\n    \n    animationFrameRef.current = requestAnimationFrame(step);\n  }, [ctxRef, canvasRef]);\n\n  const animateDomSegment = useCallback((p1, p2, callback) => {\n    if (!mouseMarkerRef.current) return;\n    \n    setAnimating(true);\n    const frames = 56; // 25% slower: 45 * 1.25 = 56.25, rounded to 56\n    let frame = 0;\n    mouseMarkerRef.current.style.display = \"block\";\n    \n    // Determine direction for this segment\n    const direction = getDirection(p1, p2);\n    let transform = '';\n    \n    // Apply transformations based on direction (image faces right by default)\n    if (direction === 'right') {\n      transform = ''; // No transformation needed\n    } else if (direction === 'down') {\n      transform = 'rotate(90deg)'; // Rotate 90 degrees clockwise\n    } else if (direction === 'left') {\n      transform = 'scaleX(-1)'; // Flip horizontally\n    } else if (direction === 'up') {\n      transform = 'rotate(-90deg)'; // Rotate 90 degrees counterclockwise\n    }\n    \n    mouseMarkerRef.current.style.transform = transform;\n\n    const step = () => {\n      if (!mouseMarkerRef.current) return;\n      \n      const t = frame / frames;\n      const x = p1.x + (p2.x - p1.x) * t;\n      const y = p1.y + (p2.y - p1.y) * t;\n      mouseMarkerRef.current.style.left = (x - 18) + \"px\"; // 50% of 36px = 18px\n      mouseMarkerRef.current.style.top = (y - 18) + \"px\"; // 50% of 36px = 18px\n\n      frame++;\n      if (frame > frames) {\n        if (callback) callback();\n        return;\n      }\n      animationFrameRef.current = requestAnimationFrame(step);\n    };\n    \n    animationFrameRef.current = requestAnimationFrame(step);\n  }, [mouseMarkerRef]);\n\n  const animateInferenceProbe = useCallback((startHole, info, after, holeRefs) => {\n    if (!mouseMarkerRef.current) return;\n    \n    const holeStartDiv = holeRefs.find(h => h && parseInt(h.dataset?.num) === startHole);\n    if (!holeStartDiv) {\n      if (after) after();\n      return;\n    }\n    \n    const startBtn = {\n      x: holeStartDiv.offsetLeft + holeStartDiv.offsetWidth / 2,\n      y: holeStartDiv.offsetTop + holeStartDiv.offsetHeight / 2\n    };\n    const startEdgeCanvas = holeWallCoords(startHole, CELL, CANVAS_SIZE, CANVAS_SIZE);\n    const startEdge = { x: startEdgeCanvas.x, y: startEdgeCanvas.y };\n\n    const doExit = () => {\n      if (info.trapped || info.exitHole === null || info.exitHole === undefined) {\n        if (mouseMarkerRef.current) {\n          mouseMarkerRef.current.style.display = \"none\";\n        }\n        setAnimating(false);\n        if (after) after();\n        return;\n      }\n      const holeExitDiv = holeRefs.find(h => h && parseInt(h.dataset?.num) === info.exitHole);\n      if (!holeExitDiv) {\n        if (mouseMarkerRef.current) {\n          mouseMarkerRef.current.style.display = \"none\";\n        }\n        setAnimating(false);\n        if (after) after();\n        return;\n      }\n      const exitEdgeCanvas = holeWallCoords(info.exitHole, CELL, CANVAS_SIZE, CANVAS_SIZE);\n      const exitEdge = { x: exitEdgeCanvas.x, y: exitEdgeCanvas.y };\n      const exitBtn = {\n        x: holeExitDiv.offsetLeft + holeExitDiv.offsetWidth / 2,\n        y: holeExitDiv.offsetTop + holeExitDiv.offsetHeight / 2\n      };\n      animateDomSegment(exitEdge, exitBtn, () => {\n        if (mouseMarkerRef.current) {\n          mouseMarkerRef.current.style.display = \"none\";\n        }\n        setAnimating(false);\n        if (after) after();\n      });\n    };\n\n    animateDomSegment(startBtn, startEdge, doExit);\n  }, [mouseMarkerRef, animateDomSegment]);\n\n  // Cleanup on unmount\n  const cleanup = useCallback(() => {\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n  }, []);\n\n  return { animating, animatePath, animateInferenceProbe, cleanup };\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}