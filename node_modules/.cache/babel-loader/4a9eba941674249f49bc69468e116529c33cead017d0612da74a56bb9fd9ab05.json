{"ast":null,"code":"// Maze generation and simulation utilities\n\nconst SIZE = 4;\nexport function randInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nexport function shuffle(arr) {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n  return arr;\n}\nexport function emptyGrid() {\n  const g = [];\n  for (let r = 0; r < SIZE; r++) g[r] = new Array(SIZE).fill(\"\");\n  return g;\n}\nexport function hasOpposingArrows(grid) {\n  for (let r = 0; r < SIZE; r++) {\n    for (let c = 0; c < SIZE; c++) {\n      const v = grid[r][c];\n      if (!v) continue;\n      if (c + 1 < SIZE) {\n        const vr = grid[r][c + 1];\n        if (v === \"R\" && vr === \"L\" || v === \"L\" && vr === \"R\") return true;\n      }\n      if (r + 1 < SIZE) {\n        const vd = grid[r + 1][c];\n        if (v === \"D\" && vd === \"U\" || v === \"U\" && vd === \"D\") return true;\n      }\n    }\n  }\n  return false;\n}\nexport function makeMazeOnce(mazeType, level) {\n  const grid = emptyGrid();\n  let minObj, maxObj;\n  if (level === \"beginner\") {\n    minObj = 1;\n    maxObj = 3;\n  } else if (level === \"intermediate\") {\n    minObj = 4;\n    maxObj = 6;\n  } else {\n    minObj = 7;\n    maxObj = 12;\n  }\n  const count = randInt(minObj, maxObj);\n  let cells = [];\n  for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) cells.push({\n    r,\n    c\n  });\n  shuffle(cells);\n  const dirs = [\"U\", \"D\", \"L\", \"R\"];\n  for (let i = 0; i < count; i++) {\n    const {\n      r,\n      c\n    } = cells[i];\n    if (mazeType === \"walls\") {\n      grid[r][c] = Math.random() < 0.5 ? \"/\" : \"\\\\\";\n    } else {\n      grid[r][c] = dirs[Math.floor(Math.random() * 4)];\n    }\n  }\n  return grid;\n}\nexport function startFromHole(h) {\n  if (h >= 1 && h <= 4) return {\n    r: 0,\n    c: h - 1,\n    dir: \"D\"\n  };\n  if (h >= 5 && h <= 8) return {\n    r: h - 5,\n    c: 3,\n    dir: \"L\"\n  };\n  if (h >= 9 && h <= 12) return {\n    r: 3,\n    c: 12 - h,\n    dir: \"U\"\n  };\n  if (h >= 13 && h <= 16) return {\n    r: 16 - h,\n    c: 0,\n    dir: \"R\"\n  };\n}\nexport function findExit(r, c) {\n  if (r < 0) return c + 1;\n  if (c >= SIZE) return 5 + r;\n  if (r >= SIZE) return 9 + (SIZE - 1 - c);\n  if (c < 0) return 13 + (SIZE - 1 - r);\n}\nexport function simulateHoleWithGrid(startHole, gridForSim) {\n  const start = startFromHole(startHole);\n  let r = start.r,\n    c = start.c,\n    dir = start.dir;\n  const path = [];\n  const visited = new Set();\n  while (true) {\n    if (r < 0 || r >= SIZE || c < 0 || c >= SIZE) {\n      const exit = findExit(r, c);\n      return {\n        path,\n        exitHole: exit,\n        trapped: false\n      };\n    }\n    const key = `${r},${c},${dir}`;\n    if (visited.has(key)) {\n      return {\n        path,\n        exitHole: null,\n        trapped: true\n      };\n    }\n    visited.add(key);\n    path.push({\n      r,\n      c\n    });\n    const v = gridForSim[r][c];\n    if (v === \"/\") {\n      if (dir === \"R\") dir = \"U\";else if (dir === \"U\") dir = \"R\";else if (dir === \"L\") dir = \"D\";else if (dir === \"D\") dir = \"L\";\n    } else if (v === \"\\\\\") {\n      if (dir === \"R\") dir = \"D\";else if (dir === \"D\") dir = \"R\";else if (dir === \"L\") dir = \"U\";else if (dir === \"U\") dir = \"L\";\n    } else if ([\"U\", \"D\", \"L\", \"R\"].includes(v)) {\n      dir = v;\n    }\n    if (dir === \"U\") r--;else if (dir === \"D\") r++;else if (dir === \"L\") c--;else if (dir === \"R\") c++;\n  }\n}\nexport function computeMappingForGrid(gridForSim) {\n  const map = {};\n  for (let h = 1; h <= 16; h++) {\n    map[h] = simulateHoleWithGrid(h, gridForSim);\n  }\n  return map;\n}\nexport function makeMaze(mazeType, level) {\n  let tries = 0;\n  let realGrid;\n  let mapping;\n  while (true) {\n    realGrid = makeMazeOnce(mazeType, level);\n    const testMap = computeMappingForGrid(realGrid);\n    let escaping = 0;\n    for (let h = 1; h <= 16; h++) {\n      if (!testMap[h].trapped && testMap[h].exitHole !== null) escaping++;\n    }\n    if (escaping > 0 && !(mazeType === \"arrows\" && level === \"beginner\" && hasOpposingArrows(realGrid))) {\n      mapping = testMap;\n      break;\n    }\n    tries++;\n    if (tries > 50) {\n      mapping = testMap;\n      break;\n    }\n  }\n  return {\n    realGrid,\n    mapping\n  };\n}\nexport function holeWallCoords(h, cell, canvasWidth, canvasHeight) {\n  if (h >= 1 && h <= 4) {\n    return {\n      x: (h - 1) * cell + cell / 2,\n      y: 0\n    };\n  }\n  if (h >= 5 && h <= 8) {\n    return {\n      x: canvasWidth,\n      y: (h - 5) * cell + cell / 2\n    };\n  }\n  if (h >= 9 && h <= 12) {\n    return {\n      x: (12 - h) * cell + cell / 2,\n      y: canvasHeight\n    };\n  }\n  if (h >= 13 && h <= 16) {\n    return {\n      x: 0,\n      y: (16 - h) * cell + cell / 2\n    };\n  }\n}\nexport { SIZE };","map":{"version":3,"names":["SIZE","randInt","min","max","Math","floor","random","shuffle","arr","i","length","j","emptyGrid","g","r","Array","fill","hasOpposingArrows","grid","c","v","vr","vd","makeMazeOnce","mazeType","level","minObj","maxObj","count","cells","push","dirs","startFromHole","h","dir","findExit","simulateHoleWithGrid","startHole","gridForSim","start","path","visited","Set","exit","exitHole","trapped","key","has","add","includes","computeMappingForGrid","map","makeMaze","tries","realGrid","mapping","testMap","escaping","holeWallCoords","cell","canvasWidth","canvasHeight","x","y"],"sources":["/Users/joshuaabrams/Library/CloudStorage/Dropbox/Professional Development Activities & Workshops/*Making Math Website/VariedContent/Geometry/LogicAndReasoning/MouseMazes/mouse-mazes-react/src/utils/mazeUtils.js"],"sourcesContent":["// Maze generation and simulation utilities\n\nconst SIZE = 4;\n\nexport function randInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nexport function shuffle(arr) {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n  return arr;\n}\n\nexport function emptyGrid() {\n  const g = [];\n  for (let r = 0; r < SIZE; r++) g[r] = new Array(SIZE).fill(\"\");\n  return g;\n}\n\nexport function hasOpposingArrows(grid) {\n  for (let r = 0; r < SIZE; r++) {\n    for (let c = 0; c < SIZE; c++) {\n      const v = grid[r][c];\n      if (!v) continue;\n      if (c + 1 < SIZE) {\n        const vr = grid[r][c+1];\n        if ((v === \"R\" && vr === \"L\") || (v === \"L\" && vr === \"R\")) return true;\n      }\n      if (r + 1 < SIZE) {\n        const vd = grid[r+1][c];\n        if ((v === \"D\" && vd === \"U\") || (v === \"U\" && vd === \"D\")) return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function makeMazeOnce(mazeType, level) {\n  const grid = emptyGrid();\n\n  let minObj, maxObj;\n  if (level === \"beginner\") { minObj = 1; maxObj = 3; }\n  else if (level === \"intermediate\") { minObj = 4; maxObj = 6; }\n  else { minObj = 7; maxObj = 12; }\n\n  const count = randInt(minObj, maxObj);\n\n  let cells = [];\n  for (let r = 0; r < SIZE; r++)\n    for (let c = 0; c < SIZE; c++)\n      cells.push({r,c});\n  shuffle(cells);\n\n  const dirs = [\"U\",\"D\",\"L\",\"R\"];\n  for (let i = 0; i < count; i++) {\n    const {r,c} = cells[i];\n    if (mazeType === \"walls\") {\n      grid[r][c] = Math.random() < 0.5 ? \"/\" : \"\\\\\";\n    } else {\n      grid[r][c] = dirs[Math.floor(Math.random() * 4)];\n    }\n  }\n  \n  return grid;\n}\n\nexport function startFromHole(h) {\n  if (h >= 1 && h <= 4) return { r: 0, c: h - 1, dir: \"D\" };\n  if (h >= 5 && h <= 8) return { r: h - 5, c: 3, dir: \"L\" };\n  if (h >= 9 && h <= 12) return { r: 3, c: 12 - h, dir: \"U\" };\n  if (h >= 13 && h <= 16) return { r: 16 - h, c: 0, dir: \"R\" };\n}\n\nexport function findExit(r, c) {\n  if (r < 0) return c + 1;\n  if (c >= SIZE) return 5 + r;\n  if (r >= SIZE) return 9 + (SIZE - 1 - c);\n  if (c < 0) return 13 + (SIZE - 1 - r);\n}\n\nexport function simulateHoleWithGrid(startHole, gridForSim) {\n  const start = startFromHole(startHole);\n  let r = start.r, c = start.c, dir = start.dir;\n  const path = [];\n  const visited = new Set();\n\n  while (true) {\n    if (r < 0 || r >= SIZE || c < 0 || c >= SIZE) {\n      const exit = findExit(r, c);\n      return { path, exitHole: exit, trapped: false };\n    }\n    const key = `${r},${c},${dir}`;\n    if (visited.has(key)) {\n      return { path, exitHole: null, trapped: true };\n    }\n    visited.add(key);\n    path.push({ r, c });\n    const v = gridForSim[r][c];\n    if (v === \"/\") {\n      if (dir === \"R\") dir = \"U\";\n      else if (dir === \"U\") dir = \"R\";\n      else if (dir === \"L\") dir = \"D\";\n      else if (dir === \"D\") dir = \"L\";\n    } else if (v === \"\\\\\") {\n      if (dir === \"R\") dir = \"D\";\n      else if (dir === \"D\") dir = \"R\";\n      else if (dir === \"L\") dir = \"U\";\n      else if (dir === \"U\") dir = \"L\";\n    } else if ([\"U\",\"D\",\"L\",\"R\"].includes(v)) {\n      dir = v;\n    }\n    if (dir === \"U\") r--;\n    else if (dir === \"D\") r++;\n    else if (dir === \"L\") c--;\n    else if (dir === \"R\") c++;\n  }\n}\n\nexport function computeMappingForGrid(gridForSim) {\n  const map = {};\n  for (let h = 1; h <= 16; h++) {\n    map[h] = simulateHoleWithGrid(h, gridForSim);\n  }\n  return map;\n}\n\nexport function makeMaze(mazeType, level) {\n  let tries = 0;\n  let realGrid;\n  let mapping;\n  \n  while (true) {\n    realGrid = makeMazeOnce(mazeType, level);\n    const testMap = computeMappingForGrid(realGrid);\n    let escaping = 0;\n    for (let h = 1; h <= 16; h++) {\n      if (!testMap[h].trapped && testMap[h].exitHole !== null) escaping++;\n    }\n    if (\n      escaping > 0 &&\n      !(mazeType === \"arrows\" && level === \"beginner\" && hasOpposingArrows(realGrid))\n    ) {\n      mapping = testMap;\n      break;\n    }\n    tries++;\n    if (tries > 50) {\n      mapping = testMap;\n      break;\n    }\n  }\n  \n  return { realGrid, mapping };\n}\n\nexport function holeWallCoords(h, cell, canvasWidth, canvasHeight) {\n  if (h >= 1 && h <= 4) {\n    return { x: (h - 1) * cell + cell / 2, y: 0 };\n  }\n  if (h >= 5 && h <= 8) {\n    return { x: canvasWidth, y: (h - 5) * cell + cell / 2 };\n  }\n  if (h >= 9 && h <= 12) {\n    return { x: (12 - h) * cell + cell / 2, y: canvasHeight };\n  }\n  if (h >= 13 && h <= 16) {\n    return { x: 0, y: (16 - h) * cell + cell / 2 };\n  }\n}\n\nexport { SIZE };\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}