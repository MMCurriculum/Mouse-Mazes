{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef } from 'react';\nimport { makeMaze, emptyGrid, computeMappingForGrid, simulateHoleWithGrid, randInt } from '../utils/mazeUtils';\nconst TOTAL_QUESTIONS = 8;\nexport function useMazeGame(mazeType, level, mode) {\n  _s();\n  const [realGrid, setRealGrid] = useState(() => emptyGrid());\n  const [modelGrid, setModelGrid] = useState(() => emptyGrid());\n  const [mapping, setMapping] = useState({});\n  const [gameActive, setGameActive] = useState(false);\n  const [questionIndex, setQuestionIndex] = useState(0);\n  const [score, setScore] = useState(0);\n  const [awaitingAnswer, setAwaitingAnswer] = useState(false);\n  const [currentQuestion, setCurrentQuestion] = useState(null);\n  const [inferenceProbeCount, setInferenceProbeCount] = useState(0);\n\n  // Refs for tracking used questions\n  const usedForwardStarts = useRef(new Set());\n  const usedReverseWallsEnds = useRef(new Set());\n  const usedReverseArrowsEnds = useRef(new Set());\n  const introColorToggle = useRef(false);\n  const chooseForwardStart = useCallback(() => {\n    const candidates = [];\n    for (let h = 1; h <= 16; h++) {\n      if (!usedForwardStarts.current.has(h)) candidates.push(h);\n    }\n    if (candidates.length === 0) return 1;\n    const startHole = candidates[randInt(0, candidates.length - 1)];\n    usedForwardStarts.current.add(startHole);\n    return startHole;\n  }, []);\n  const chooseReverseWalls = useCallback(mapping => {\n    const pairs = [];\n    for (let h = 1; h <= 16; h++) {\n      const info = mapping[h];\n      if (!info.trapped && info.exitHole !== null && !usedReverseWallsEnds.current.has(info.exitHole)) {\n        pairs.push({\n          startHole: h,\n          endHole: info.exitHole\n        });\n      }\n    }\n    if (pairs.length === 0) return null;\n    const choice = pairs[randInt(0, pairs.length - 1)];\n    usedReverseWallsEnds.current.add(choice.endHole);\n    return choice;\n  }, []);\n  const chooseReverseArrows = useCallback(mapping => {\n    const endMap = {};\n    for (let h = 1; h <= 16; h++) {\n      const info = mapping[h];\n      if (!info.trapped && info.exitHole !== null && !usedReverseArrowsEnds.current.has(info.exitHole)) {\n        if (!endMap[info.exitHole]) endMap[info.exitHole] = [];\n        endMap[info.exitHole].push(h);\n      }\n    }\n    const ends = Object.keys(endMap);\n    if (ends.length === 0) return null;\n    const endHole = parseInt(ends[randInt(0, ends.length - 1)]);\n    usedReverseArrowsEnds.current.add(endHole);\n    const starts = endMap[endHole];\n    return {\n      endHole,\n      starts\n    };\n  }, []);\n  const startIntroGame = useCallback(() => {\n    setGameActive(true);\n    setQuestionIndex(0);\n    setScore(0);\n    usedForwardStarts.current = new Set();\n    usedReverseWallsEnds.current = new Set();\n    usedReverseArrowsEnds.current = new Set();\n    const {\n      realGrid: newRealGrid,\n      mapping: newMapping\n    } = makeMaze(mazeType, level);\n    setRealGrid(newRealGrid);\n    setMapping(newMapping);\n    setModelGrid(emptyGrid());\n    setQuestionIndex(1);\n    setAwaitingAnswer(true);\n\n    // Return question data for first question\n    let useReverse = false;\n    if (level === \"intermediate\") useReverse = Math.random() < 0.4;else if (level === \"expert\") useReverse = Math.random() < 0.6;\n    if (!useReverse) {\n      const startHole = chooseForwardStart();\n      const info = newMapping[startHole];\n      const question = {\n        mode: \"forward\",\n        startHole,\n        exitHole: info.exitHole,\n        trapped: info.trapped\n      };\n      setCurrentQuestion(question);\n      return {\n        question,\n        questionIndex: 1\n      };\n    } else {\n      if (mazeType === \"walls\") {\n        const choice = chooseReverseWalls(newMapping);\n        if (!choice) {\n          // Retry with forward\n          const startHole = chooseForwardStart();\n          const info = newMapping[startHole];\n          const question = {\n            mode: \"forward\",\n            startHole,\n            exitHole: info.exitHole,\n            trapped: info.trapped\n          };\n          setCurrentQuestion(question);\n          return {\n            question,\n            questionIndex: 1\n          };\n        }\n        const {\n          endHole,\n          startHole\n        } = choice;\n        const question = {\n          mode: \"reverseWalls\",\n          endHole,\n          startHole\n        };\n        setCurrentQuestion(question);\n        return {\n          question,\n          questionIndex: 1\n        };\n      } else {\n        const choice = chooseReverseArrows(newMapping);\n        if (!choice) {\n          // Retry with forward\n          const startHole = chooseForwardStart();\n          const info = newMapping[startHole];\n          const question = {\n            mode: \"forward\",\n            startHole,\n            exitHole: info.exitHole,\n            trapped: info.trapped\n          };\n          setCurrentQuestion(question);\n          return {\n            question,\n            questionIndex: 1\n          };\n        }\n        const {\n          endHole,\n          starts\n        } = choice;\n        const question = {\n          mode: \"reverseArrows\",\n          endHole,\n          starts\n        };\n        setCurrentQuestion(question);\n        return {\n          question,\n          questionIndex: 1\n        };\n      }\n    }\n  }, [mazeType, level, chooseForwardStart, chooseReverseWalls, chooseReverseArrows]);\n  const nextQuestion = useCallback(currentMapping => {\n    setQuestionIndex(prev => {\n      const newIndex = prev + 1;\n      if (newIndex > TOTAL_QUESTIONS) {\n        setGameActive(false);\n        setAwaitingAnswer(false);\n        return newIndex;\n      }\n      let useReverse = false;\n      if (level === \"intermediate\") useReverse = Math.random() < 0.4;else if (level === \"expert\") useReverse = Math.random() < 0.6;\n      if (!useReverse) {\n        const startHole = chooseForwardStart();\n        const info = currentMapping[startHole];\n        const question = {\n          mode: \"forward\",\n          startHole,\n          exitHole: info.exitHole,\n          trapped: info.trapped\n        };\n        setCurrentQuestion(question);\n        setAwaitingAnswer(true);\n        return newIndex;\n      } else {\n        if (mazeType === \"walls\") {\n          const choice = chooseReverseWalls(currentMapping);\n          if (!choice) {\n            // Retry with forward\n            const startHole = chooseForwardStart();\n            const info = currentMapping[startHole];\n            const question = {\n              mode: \"forward\",\n              startHole,\n              exitHole: info.exitHole,\n              trapped: info.trapped\n            };\n            setCurrentQuestion(question);\n            setAwaitingAnswer(true);\n            return newIndex;\n          }\n          const {\n            endHole,\n            startHole\n          } = choice;\n          const question = {\n            mode: \"reverseWalls\",\n            endHole,\n            startHole\n          };\n          setCurrentQuestion(question);\n          setAwaitingAnswer(true);\n          return newIndex;\n        } else {\n          const choice = chooseReverseArrows(currentMapping);\n          if (!choice) {\n            // Retry with forward\n            const startHole = chooseForwardStart();\n            const info = currentMapping[startHole];\n            const question = {\n              mode: \"forward\",\n              startHole,\n              exitHole: info.exitHole,\n              trapped: info.trapped\n            };\n            setCurrentQuestion(question);\n            setAwaitingAnswer(true);\n            return newIndex;\n          }\n          const {\n            endHole,\n            starts\n          } = choice;\n          const question = {\n            mode: \"reverseArrows\",\n            endHole,\n            starts\n          };\n          setCurrentQuestion(question);\n          setAwaitingAnswer(true);\n          return newIndex;\n        }\n      }\n    });\n  }, [level, mazeType, chooseForwardStart, chooseReverseWalls, chooseReverseArrows]);\n  const handleIntroAnswer = useCallback((holeNum, isNoExit) => {\n    if (!gameActive || !awaitingAnswer) {\n      if (holeNum == null) return null;\n      const info = mapping[holeNum] || simulateHoleWithGrid(holeNum, realGrid);\n      return {\n        info,\n        animStartHole: holeNum,\n        after: () => ({\n          feedback: '',\n          feedbackClass: '',\n          isCorrect: undefined\n        })\n      };\n    }\n    setAwaitingAnswer(false);\n    const q = currentQuestion;\n    if (!q) return null;\n    let isCorrect = false;\n    let animStartHole;\n    if (q.mode === \"forward\") {\n      animStartHole = q.startHole;\n      if (q.trapped && mazeType === \"arrows\") {\n        isCorrect = isNoExit;\n      } else {\n        isCorrect = !isNoExit && holeNum === q.exitHole;\n      }\n    } else if (q.mode === \"reverseWalls\") {\n      animStartHole = q.startHole;\n      isCorrect = !isNoExit && holeNum === q.startHole;\n    } else {\n      if (isNoExit) {\n        animStartHole = q.starts[0];\n        isCorrect = false;\n      } else {\n        animStartHole = holeNum;\n        isCorrect = q.starts.includes(holeNum);\n      }\n    }\n    const info = mapping[animStartHole] || simulateHoleWithGrid(animStartHole, realGrid);\n    const after = () => {\n      if (isCorrect) {\n        setScore(prev => prev + 1);\n      }\n\n      // Return feedback data\n      let feedback = \"\";\n      let feedbackClass = \"\";\n      if (isCorrect) {\n        if (info.trapped && q.mode === \"forward\" && mazeType === \"arrows\") {\n          feedback = \"Nice work — in this maze that mouse never comes out.\";\n        } else {\n          feedback = \"Nice work — that matches the maze.\";\n        }\n        feedbackClass = \"correct\";\n      } else {\n        if (info.trapped) {\n          if (q.mode === \"forward\" && mazeType === \"arrows\" && !isNoExit) {\n            feedback = \"That mouse is stuck in the house forever — the correct choice was that it doesn't come out.\";\n          } else {\n            feedback = \"That mouse is stuck in the house forever!\";\n          }\n          feedbackClass = \"\";\n        } else {\n          if (q.mode === \"forward\") {\n            feedback = `Oops — it actually came out of hole ${q.exitHole}.`;\n          } else if (q.mode === \"reverseWalls\") {\n            feedback = `Oops — it actually started at hole ${q.startHole}.`;\n          } else {\n            const list = q.starts.join(\", \");\n            feedback = `Oops — one possible starting hole was ${list}.`;\n          }\n          feedbackClass = \"incorrect\";\n        }\n      }\n      return {\n        feedback,\n        feedbackClass,\n        isCorrect\n      };\n    };\n    return {\n      info,\n      animStartHole,\n      after\n    };\n  }, [gameActive, awaitingAnswer, currentQuestion, mapping, realGrid, mazeType]);\n  const handleInferenceProbe = useCallback(holeNum => {\n    setInferenceProbeCount(prev => prev + 1);\n    const info = mapping[holeNum] || simulateHoleWithGrid(holeNum, realGrid);\n    return {\n      info,\n      probeCount: inferenceProbeCount + 1\n    };\n  }, [mapping, realGrid, inferenceProbeCount]);\n  const testModel = useCallback(() => {\n    console.log('=== TESTING MODEL ===');\n    console.log('Real Grid State:', realGrid);\n    console.log('Real Grid (formatted):');\n    console.log(realGrid.map((row, r) => row.map((cell, c) => `${r},${c}:${cell || 'empty'}`).join(' | ')).join('\\n'));\n    console.log('Model Grid State:', modelGrid);\n    console.log('Model Grid (formatted):');\n    console.log(modelGrid.map((row, r) => row.map((cell, c) => `${r},${c}:${cell || 'empty'}`).join(' | ')).join('\\n'));\n    const modelMap = computeMappingForGrid(modelGrid);\n    console.log('Model Mapping (computed from grid):', modelMap);\n    const realMap = mapping;\n    console.log('Real Mapping (actual maze):', realMap);\n    let matches = 0;\n    for (let h = 1; h <= 16; h++) {\n      const a = realMap[h];\n      const b = modelMap[h];\n      let same = false;\n      if (a.trapped && b.trapped) same = true;else if (!a.trapped && !b.trapped && a.exitHole === b.exitHole) same = true;\n      if (same) matches++;\n    }\n    let sameLayout = true;\n    for (let r = 0; r < 4; r++) {\n      for (let c = 0; c < 4; c++) {\n        if (realGrid[r][c] !== modelGrid[r][c]) {\n          sameLayout = false;\n          break;\n        }\n      }\n      if (!sameLayout) break;\n    }\n    const probeMsg = ` You have sent ${inferenceProbeCount} mice into the maze.`;\n    let feedback = \"\";\n    if (matches === 16) {\n      if (sameLayout) {\n        feedback = \"Your model is right! All 16 mice behave correctly and your layout matches the hidden one.\" + probeMsg;\n      } else {\n        feedback = \"Your model works. All 16 mice behave correctly, though your layout is different from mine. More than one right answer is possible.\" + probeMsg;\n      }\n    } else {\n      feedback = `${matches} of your mice arrive in the right place for that model.` + probeMsg;\n    }\n    return {\n      feedback\n    };\n  }, [modelGrid, mapping, realGrid, inferenceProbeCount]);\n  const resetModelGrid = useCallback(() => {\n    setModelGrid(emptyGrid());\n  }, []);\n  const startInferenceGame = useCallback(() => {\n    setGameActive(false);\n    setAwaitingAnswer(false);\n    const {\n      realGrid: newRealGrid,\n      mapping: newMapping\n    } = makeMaze(mazeType, level);\n    setRealGrid(newRealGrid);\n    setMapping(newMapping);\n    setModelGrid(emptyGrid());\n    setInferenceProbeCount(0);\n    return {\n      realGrid: newRealGrid,\n      mapping: newMapping\n    };\n  }, [mazeType, level]);\n  const updateModelGrid = useCallback((r, c, value) => {\n    setModelGrid(prev => {\n      const newGrid = prev.map(row => [...row]);\n      newGrid[r][c] = value;\n      console.log(`Model Grid Updated: [${r}][${c}] = \"${value}\"`);\n      console.log('Current Model Grid:', newGrid);\n      return newGrid;\n    });\n  }, []);\n  const toggleIntroColor = useCallback(() => {\n    introColorToggle.current = !introColorToggle.current;\n    return introColorToggle.current;\n  }, []);\n  return {\n    realGrid,\n    modelGrid,\n    mapping,\n    gameActive,\n    questionIndex,\n    score,\n    awaitingAnswer,\n    currentQuestion,\n    inferenceProbeCount,\n    TOTAL_QUESTIONS,\n    startIntroGame,\n    handleIntroAnswer,\n    nextQuestion,\n    handleInferenceProbe,\n    testModel,\n    resetModelGrid,\n    startInferenceGame,\n    updateModelGrid,\n    toggleIntroColor\n  };\n}\n_s(useMazeGame, \"TX01gAWDAUAYCG3yxa9x4hmiqlM=\");","map":{"version":3,"names":["useState","useCallback","useRef","makeMaze","emptyGrid","computeMappingForGrid","simulateHoleWithGrid","randInt","TOTAL_QUESTIONS","useMazeGame","mazeType","level","mode","_s","realGrid","setRealGrid","modelGrid","setModelGrid","mapping","setMapping","gameActive","setGameActive","questionIndex","setQuestionIndex","score","setScore","awaitingAnswer","setAwaitingAnswer","currentQuestion","setCurrentQuestion","inferenceProbeCount","setInferenceProbeCount","usedForwardStarts","Set","usedReverseWallsEnds","usedReverseArrowsEnds","introColorToggle","chooseForwardStart","candidates","h","current","has","push","length","startHole","add","chooseReverseWalls","pairs","info","trapped","exitHole","endHole","choice","chooseReverseArrows","endMap","ends","Object","keys","parseInt","starts","startIntroGame","newRealGrid","newMapping","useReverse","Math","random","question","nextQuestion","currentMapping","prev","newIndex","handleIntroAnswer","holeNum","isNoExit","animStartHole","after","feedback","feedbackClass","isCorrect","undefined","q","includes","list","join","handleInferenceProbe","probeCount","testModel","console","log","map","row","r","cell","c","modelMap","realMap","matches","a","b","same","sameLayout","probeMsg","resetModelGrid","startInferenceGame","updateModelGrid","value","newGrid","toggleIntroColor"],"sources":["/Users/joshuaabrams/Library/CloudStorage/Dropbox/Professional Development Activities & Workshops/*Making Math Website/VariedContent/Geometry/LogicAndReasoning/MouseMazes/mouse-mazes-react/src/hooks/useMazeGame.js"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\nimport { makeMaze, emptyGrid, computeMappingForGrid, simulateHoleWithGrid, randInt } from '../utils/mazeUtils';\n\nconst TOTAL_QUESTIONS = 8;\n\nexport function useMazeGame(mazeType, level, mode) {\n  const [realGrid, setRealGrid] = useState(() => emptyGrid());\n  const [modelGrid, setModelGrid] = useState(() => emptyGrid());\n  const [mapping, setMapping] = useState({});\n  const [gameActive, setGameActive] = useState(false);\n  const [questionIndex, setQuestionIndex] = useState(0);\n  const [score, setScore] = useState(0);\n  const [awaitingAnswer, setAwaitingAnswer] = useState(false);\n  const [currentQuestion, setCurrentQuestion] = useState(null);\n  const [inferenceProbeCount, setInferenceProbeCount] = useState(0);\n  \n  // Refs for tracking used questions\n  const usedForwardStarts = useRef(new Set());\n  const usedReverseWallsEnds = useRef(new Set());\n  const usedReverseArrowsEnds = useRef(new Set());\n  const introColorToggle = useRef(false);\n\n  const chooseForwardStart = useCallback(() => {\n    const candidates = [];\n    for (let h = 1; h <= 16; h++) {\n      if (!usedForwardStarts.current.has(h)) candidates.push(h);\n    }\n    if (candidates.length === 0) return 1;\n    const startHole = candidates[randInt(0, candidates.length - 1)];\n    usedForwardStarts.current.add(startHole);\n    return startHole;\n  }, []);\n\n  const chooseReverseWalls = useCallback((mapping) => {\n    const pairs = [];\n    for (let h = 1; h <= 16; h++) {\n      const info = mapping[h];\n      if (!info.trapped && info.exitHole !== null &&\n          !usedReverseWallsEnds.current.has(info.exitHole)) {\n        pairs.push({startHole: h, endHole: info.exitHole});\n      }\n    }\n    if (pairs.length === 0) return null;\n    const choice = pairs[randInt(0, pairs.length - 1)];\n    usedReverseWallsEnds.current.add(choice.endHole);\n    return choice;\n  }, []);\n\n  const chooseReverseArrows = useCallback((mapping) => {\n    const endMap = {};\n    for (let h = 1; h <= 16; h++) {\n      const info = mapping[h];\n      if (!info.trapped && info.exitHole !== null &&\n          !usedReverseArrowsEnds.current.has(info.exitHole)) {\n        if (!endMap[info.exitHole]) endMap[info.exitHole] = [];\n        endMap[info.exitHole].push(h);\n      }\n    }\n    const ends = Object.keys(endMap);\n    if (ends.length === 0) return null;\n    const endHole = parseInt(ends[randInt(0, ends.length - 1)]);\n    usedReverseArrowsEnds.current.add(endHole);\n    const starts = endMap[endHole];\n    return {endHole, starts};\n  }, []);\n\n  const startIntroGame = useCallback(() => {\n    setGameActive(true);\n    setQuestionIndex(0);\n    setScore(0);\n    usedForwardStarts.current = new Set();\n    usedReverseWallsEnds.current = new Set();\n    usedReverseArrowsEnds.current = new Set();\n    \n    const { realGrid: newRealGrid, mapping: newMapping } = makeMaze(mazeType, level);\n    setRealGrid(newRealGrid);\n    setMapping(newMapping);\n    setModelGrid(emptyGrid());\n    setQuestionIndex(1);\n    setAwaitingAnswer(true);\n    \n    // Return question data for first question\n    let useReverse = false;\n    if (level === \"intermediate\") useReverse = Math.random() < 0.4;\n    else if (level === \"expert\") useReverse = Math.random() < 0.6;\n\n    if (!useReverse) {\n      const startHole = chooseForwardStart();\n      const info = newMapping[startHole];\n      const question = {\n        mode: \"forward\",\n        startHole,\n        exitHole: info.exitHole,\n        trapped: info.trapped\n      };\n      setCurrentQuestion(question);\n      return { question, questionIndex: 1 };\n    } else {\n      if (mazeType === \"walls\") {\n        const choice = chooseReverseWalls(newMapping);\n        if (!choice) {\n          // Retry with forward\n          const startHole = chooseForwardStart();\n          const info = newMapping[startHole];\n          const question = {\n            mode: \"forward\",\n            startHole,\n            exitHole: info.exitHole,\n            trapped: info.trapped\n          };\n          setCurrentQuestion(question);\n          return { question, questionIndex: 1 };\n        }\n        const {endHole, startHole} = choice;\n        const question = {\n          mode:\"reverseWalls\",\n          endHole,\n          startHole\n        };\n        setCurrentQuestion(question);\n        return { question, questionIndex: 1 };\n      } else {\n        const choice = chooseReverseArrows(newMapping);\n        if (!choice) {\n          // Retry with forward\n          const startHole = chooseForwardStart();\n          const info = newMapping[startHole];\n          const question = {\n            mode: \"forward\",\n            startHole,\n            exitHole: info.exitHole,\n            trapped: info.trapped\n          };\n          setCurrentQuestion(question);\n          return { question, questionIndex: 1 };\n        }\n        const {endHole, starts} = choice;\n        const question = {\n          mode:\"reverseArrows\",\n          endHole,\n          starts\n        };\n        setCurrentQuestion(question);\n        return { question, questionIndex: 1 };\n      }\n    }\n  }, [mazeType, level, chooseForwardStart, chooseReverseWalls, chooseReverseArrows]);\n\n  const nextQuestion = useCallback((currentMapping) => {\n    setQuestionIndex(prev => {\n      const newIndex = prev + 1;\n      if (newIndex > TOTAL_QUESTIONS) {\n        setGameActive(false);\n        setAwaitingAnswer(false);\n        return newIndex;\n      }\n\n      let useReverse = false;\n      if (level === \"intermediate\") useReverse = Math.random() < 0.4;\n      else if (level === \"expert\") useReverse = Math.random() < 0.6;\n\n      if (!useReverse) {\n        const startHole = chooseForwardStart();\n        const info = currentMapping[startHole];\n        const question = {\n          mode: \"forward\",\n          startHole,\n          exitHole: info.exitHole,\n          trapped: info.trapped\n        };\n        setCurrentQuestion(question);\n        setAwaitingAnswer(true);\n        return newIndex;\n      } else {\n        if (mazeType === \"walls\") {\n          const choice = chooseReverseWalls(currentMapping);\n          if (!choice) {\n            // Retry with forward\n            const startHole = chooseForwardStart();\n            const info = currentMapping[startHole];\n            const question = {\n              mode: \"forward\",\n              startHole,\n              exitHole: info.exitHole,\n              trapped: info.trapped\n            };\n            setCurrentQuestion(question);\n            setAwaitingAnswer(true);\n            return newIndex;\n          }\n          const {endHole, startHole} = choice;\n          const question = {\n            mode:\"reverseWalls\",\n            endHole,\n            startHole\n          };\n          setCurrentQuestion(question);\n          setAwaitingAnswer(true);\n          return newIndex;\n        } else {\n          const choice = chooseReverseArrows(currentMapping);\n          if (!choice) {\n            // Retry with forward\n            const startHole = chooseForwardStart();\n            const info = currentMapping[startHole];\n            const question = {\n              mode: \"forward\",\n              startHole,\n              exitHole: info.exitHole,\n              trapped: info.trapped\n            };\n            setCurrentQuestion(question);\n            setAwaitingAnswer(true);\n            return newIndex;\n          }\n          const {endHole, starts} = choice;\n          const question = {\n            mode:\"reverseArrows\",\n            endHole,\n            starts\n          };\n          setCurrentQuestion(question);\n          setAwaitingAnswer(true);\n          return newIndex;\n        }\n      }\n    });\n  }, [level, mazeType, chooseForwardStart, chooseReverseWalls, chooseReverseArrows]);\n\n  const handleIntroAnswer = useCallback((holeNum, isNoExit) => {\n    if (!gameActive || !awaitingAnswer) {\n      if (holeNum == null) return null;\n      const info = mapping[holeNum] || simulateHoleWithGrid(holeNum, realGrid);\n      return {\n        info,\n        animStartHole: holeNum,\n        after: () => ({ feedback: '', feedbackClass: '', isCorrect: undefined })\n      };\n    }\n\n    setAwaitingAnswer(false);\n    const q = currentQuestion;\n    if (!q) return null;\n    \n    let isCorrect = false;\n    let animStartHole;\n\n    if (q.mode === \"forward\") {\n      animStartHole = q.startHole;\n      if (q.trapped && mazeType === \"arrows\") {\n        isCorrect = isNoExit;\n      } else {\n        isCorrect = (!isNoExit && holeNum === q.exitHole);\n      }\n    } else if (q.mode === \"reverseWalls\") {\n      animStartHole = q.startHole;\n      isCorrect = (!isNoExit && holeNum === q.startHole);\n    } else {\n      if (isNoExit) {\n        animStartHole = q.starts[0];\n        isCorrect = false;\n      } else {\n        animStartHole = holeNum;\n        isCorrect = q.starts.includes(holeNum);\n      }\n    }\n\n    const info = mapping[animStartHole] || simulateHoleWithGrid(animStartHole, realGrid);\n\n    const after = () => {\n      if (isCorrect) {\n        setScore(prev => prev + 1);\n      }\n      \n      // Return feedback data\n      let feedback = \"\";\n      let feedbackClass = \"\";\n      \n      if (isCorrect) {\n        if (info.trapped && q.mode === \"forward\" && mazeType === \"arrows\") {\n          feedback = \"Nice work — in this maze that mouse never comes out.\";\n        } else {\n          feedback = \"Nice work — that matches the maze.\";\n        }\n        feedbackClass = \"correct\";\n      } else {\n        if (info.trapped) {\n          if (q.mode === \"forward\" && mazeType === \"arrows\" && !isNoExit) {\n            feedback = \"That mouse is stuck in the house forever — the correct choice was that it doesn't come out.\";\n          } else {\n            feedback = \"That mouse is stuck in the house forever!\";\n          }\n          feedbackClass = \"\";\n        } else {\n          if (q.mode === \"forward\") {\n            feedback = `Oops — it actually came out of hole ${q.exitHole}.`;\n          } else if (q.mode === \"reverseWalls\") {\n            feedback = `Oops — it actually started at hole ${q.startHole}.`;\n          } else {\n            const list = q.starts.join(\", \");\n            feedback = `Oops — one possible starting hole was ${list}.`;\n          }\n          feedbackClass = \"incorrect\";\n        }\n      }\n\n      return { feedback, feedbackClass, isCorrect };\n    };\n\n    return { info, animStartHole, after };\n  }, [gameActive, awaitingAnswer, currentQuestion, mapping, realGrid, mazeType]);\n\n  const handleInferenceProbe = useCallback((holeNum) => {\n    setInferenceProbeCount(prev => prev + 1);\n    const info = mapping[holeNum] || simulateHoleWithGrid(holeNum, realGrid);\n    return { info, probeCount: inferenceProbeCount + 1 };\n  }, [mapping, realGrid, inferenceProbeCount]);\n\n  const testModel = useCallback(() => {\n    console.log('=== TESTING MODEL ===');\n    console.log('Real Grid State:', realGrid);\n    console.log('Real Grid (formatted):');\n    console.log(realGrid.map((row, r) => \n      row.map((cell, c) => `${r},${c}:${cell || 'empty'}`).join(' | ')\n    ).join('\\n'));\n    \n    console.log('Model Grid State:', modelGrid);\n    console.log('Model Grid (formatted):');\n    console.log(modelGrid.map((row, r) => \n      row.map((cell, c) => `${r},${c}:${cell || 'empty'}`).join(' | ')\n    ).join('\\n'));\n    \n    const modelMap = computeMappingForGrid(modelGrid);\n    console.log('Model Mapping (computed from grid):', modelMap);\n    \n    const realMap = mapping;\n    console.log('Real Mapping (actual maze):', realMap);\n\n    let matches = 0;\n    for (let h = 1; h <= 16; h++) {\n      const a = realMap[h];\n      const b = modelMap[h];\n      let same = false;\n      if (a.trapped && b.trapped) same = true;\n      else if (!a.trapped && !b.trapped && a.exitHole === b.exitHole) same = true;\n      if (same) matches++;\n    }\n\n    let sameLayout = true;\n    for (let r = 0; r < 4; r++) {\n      for (let c = 0; c < 4; c++) {\n        if (realGrid[r][c] !== modelGrid[r][c]) {\n          sameLayout = false;\n          break;\n        }\n      }\n      if (!sameLayout) break;\n    }\n\n    const probeMsg = ` You have sent ${inferenceProbeCount} mice into the maze.`;\n\n    let feedback = \"\";\n    if (matches === 16) {\n      if (sameLayout) {\n        feedback = \"Your model is right! All 16 mice behave correctly and your layout matches the hidden one.\" + probeMsg;\n      } else {\n        feedback = \"Your model works. All 16 mice behave correctly, though your layout is different from mine. More than one right answer is possible.\" + probeMsg;\n      }\n    } else {\n      feedback = `${matches} of your mice arrive in the right place for that model.` + probeMsg;\n    }\n\n    return { feedback };\n  }, [modelGrid, mapping, realGrid, inferenceProbeCount]);\n\n  const resetModelGrid = useCallback(() => {\n    setModelGrid(emptyGrid());\n  }, []);\n\n  const startInferenceGame = useCallback(() => {\n    setGameActive(false);\n    setAwaitingAnswer(false);\n    const { realGrid: newRealGrid, mapping: newMapping } = makeMaze(mazeType, level);\n    setRealGrid(newRealGrid);\n    setMapping(newMapping);\n    setModelGrid(emptyGrid());\n    setInferenceProbeCount(0);\n    return { realGrid: newRealGrid, mapping: newMapping };\n  }, [mazeType, level]);\n\n  const updateModelGrid = useCallback((r, c, value) => {\n    setModelGrid(prev => {\n      const newGrid = prev.map(row => [...row]);\n      newGrid[r][c] = value;\n      console.log(`Model Grid Updated: [${r}][${c}] = \"${value}\"`);\n      console.log('Current Model Grid:', newGrid);\n      return newGrid;\n    });\n  }, []);\n\n  const toggleIntroColor = useCallback(() => {\n    introColorToggle.current = !introColorToggle.current;\n    return introColorToggle.current;\n  }, []);\n\n  return {\n    realGrid,\n    modelGrid,\n    mapping,\n    gameActive,\n    questionIndex,\n    score,\n    awaitingAnswer,\n    currentQuestion,\n    inferenceProbeCount,\n    TOTAL_QUESTIONS,\n    startIntroGame,\n    handleIntroAnswer,\n    nextQuestion,\n    handleInferenceProbe,\n    testModel,\n    resetModelGrid,\n    startInferenceGame,\n    updateModelGrid,\n    toggleIntroColor\n  };\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}